<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>编程基础——C++语言基础知识</title>
    <link href="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1>C++语言基础知识</h1><h2 id="一、控制台程序的基本结构">一、控制台程序的基本结构</h2><p>这是最简单的helloworld代码，#开头的是预处理语句，可以用来包含一些库文件，<code>using namespace std;</code>这个语句表明这段程序使用namespace的用户空间，不去详细说但在刚开始学的阶段建议加上这一行。<code>int main()</code>定义出了主函数，一个完整的程序一定要有至少一个主函数。<code>int main()</code>中的<code>int</code>表示返回值类型，所以这个函数最后一行是一个return 0;也就是返回0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>      cout&lt;&lt;<span class="hljs-string">&quot;Hello world!!!&quot;</span>&lt;&lt;endl;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>后面编写程序都先从这个框架开始。</p><h2 id="二、输入输出语句">二、输入输出语句</h2><h3 id="（1）输出语句cout">（1）输出语句cout</h3><h3 id="（2）输入语句cin">（2）输入语句cin</h3><h2 id="三、变量和常量">三、变量和常量</h2><h3 id="（1）常量">（1）常量</h3><h4 id="1-整数">1. 整数</h4><h4 id="2-浮点数">2. 浮点数</h4><h3 id="（2）变量">（2）变量</h3><h4 id="1-整型">1. 整型</h4><h4 id="2-浮点型">2. 浮点型</h4><h4 id="3-布尔型">3. 布尔型</h4><h4 id="4-字符型">4. 字符型</h4><h4 id="5-字符串类型">5. 字符串类型</h4><h2 id="四、基本程序结构">四、基本程序结构</h2><h3 id="（1）顺序结构">（1）顺序结构</h3><h3 id="（2）选择结构">（2）选择结构</h3><h3 id="（3）循环结构">（3）循环结构</h3>]]></content>
    
    
    <categories>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程基础</tag>
      
      <tag>C++</tag>
      
      <tag>语言基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程基础——C++开发与学习环境搭建</title>
    <link href="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1>C++开发与学习环境搭建</h1><blockquote><p>零门槛初识C++，用最简单的方式开始自己的第一行代码。</p></blockquote><h2 id="一、下载编译器-IDE-文本编辑器">一、下载编译器/IDE/文本编辑器</h2><p>为了方便起见，微软的经典集成开发环境Visual C++ 6.0非常适合入门，这里提供<a href="https://wwt.lanzouw.com/iV5Qp25s8xjg">下载链接</a>。</p><h2 id="二、安装Visual-C-6-0">二、安装Visual C++ 6.0</h2><p>1.双击安装包运行安装程序</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1.png" class="" title="无描述"><p>2.点击下一步</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/2.png" class="" title="无描述"><p>3.修改安装路径，如果不想安装到C盘自行进行修改</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/3.png" class="" title="无描述"><p>4.快捷方式的勾默认打上，点击下一步</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/4.png" class="" title="无描述"><p>5.点击安装</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/5.png" class="" title="无描述"><p>6.安装完成点击完成，此时软件主界面应打开</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/6.png" class="" title="无描述"><p>7.主页面如下图</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/7.png" class="" title="无描述"><h2 id="三、创建项目">三、创建项目</h2><p>一个项目代表一个程序。</p><p>1.点击左上角FIle-&gt;New</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/8.png" class="" title="无描述"><p>2.在弹出窗口中选择Project-&gt;Win32 Console Applications</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/9.png" class="" title="无描述"><p>3.在窗口右侧给项目起名字，并为项目选择路径，路径默认即可。</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/10.png" class="" title="无描述"><p>4.下面的页面一般选择第一个即可，但我们这里选择第三个，因为第三个选项内置了几行代码。</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/11.png" class="" title="无描述"><p>5.下面点击OK</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/12.png" class="" title="无描述"><p>6.进入代码编辑页面</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/13.png" class="" title="无描述"><h2 id="四、界面-窗口介绍">四、界面/窗口介绍</h2><p>点击下方图中File View可以查看项目的文件，C++语言的代码一般头文件使用.hpp或者.h后缀，源程序本体则是.cpp，至于什么是头文件，与.cpp文件有什么区别，后面便知道。</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/14.png" class="" title="无描述"><p>屏幕左侧显示文件，屏幕右侧显示代码编辑窗口，屏幕上方是菜单和工具栏。</p><h2 id="五、运行代码">五、运行代码</h2><p>点击上方菜单中的Build-&gt;Execute test1.exe即可执行编写的代码。</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/17.png" class="" title="无描述"><p>如果弹出下面的窗口点击是即可，这个窗口的含义是还没有编译程序，是否进行编译。</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/18.png" class="" title="无描述"><p>如出现兼容性问题如下图，勾选<code>不再显示此消息</code>后点击<code>运行而不获取帮助</code>即可运行。</p><img src="/2024/07/28/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94C-%E5%BC%80%E5%8F%91%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/19.png" class="" title="无描述">]]></content>
    
    
    <categories>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程基础</tag>
      
      <tag>C++</tag>
      
      <tag>开发环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——源代码合集</title>
    <link href="/2024/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/"/>
    <url>/2024/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1>数据结构源代码合集</h1><h2 id="一、线性表">一、线性表</h2><blockquote><p>其他介绍详见<a href="https://blog.cxhap.top/2024/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构——线性表</a>。</p></blockquote><h3 id="（1）顺序表">（1）顺序表</h3><h4 id="静态分配">静态分配</h4>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-8f7bdefe" role="button" aria-expanded="false" aria-controls="collapse-8f7bdefe">        <div class="fold-arrow">▶</div>title      </div>      <div class="fold-collapse collapse" id="collapse-8f7bdefe">        <div class="fold-content">          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 静态分配顺序表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SqList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data[MaxSize];<br>    <span class="hljs-type">int</span> length;<br><br>    <span class="hljs-built_in">SqList</span>() &#123;<br>        length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MaxSize; ++i) &#123;<br>            data[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>    <span class="hljs-comment">// 函数声明</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>;                           <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span></span>;                        <span class="hljs-comment">// 销毁</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>;                          <span class="hljs-comment">// 重置为空表</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span></span>;                    <span class="hljs-comment">// 打印</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span></span>;                    <span class="hljs-comment">// 判空</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span></span>;                    <span class="hljs-comment">// 获取长度</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>;       <span class="hljs-comment">// 按位查找</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> e)</span></span>;             <span class="hljs-comment">// 按值查找</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span></span>; <span class="hljs-comment">// 查找前驱</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span></span>; <span class="hljs-comment">// 查找后继</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>;           <span class="hljs-comment">// 插入</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>;          <span class="hljs-comment">// 删除</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span></span>; <span class="hljs-comment">// 遍历</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocateChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> em)</span></span>;    <span class="hljs-comment">// 先按值查找后改值</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> em)</span></span>;       <span class="hljs-comment">// 先按位序查找后改值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testModule</span><span class="hljs-params">()</span></span>;                                  <span class="hljs-comment">// 测试模块</span><br><br>    <span class="hljs-comment">// 实现模块</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>        L.length = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>        <span class="hljs-comment">// 静态分配，无需显式销毁</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>        L.length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MaxSize; ++i) &#123;<br>            L.data[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;开始打印顺序表\n&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Data[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]==&quot;</span> &lt;&lt; L.data[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;打印结束！\n&quot;</span>;<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e = L.data[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回位序</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 未找到返回0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == cur_e) &#123;<br>            pre_e = L.data[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == cur_e) &#123;<br>            next_e = L.data[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span> || L.length &gt;= MaxSize)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length; j &gt;= i; --j) &#123;<br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    L.data[i - <span class="hljs-number">1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e = L.data[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; L.length; ++j) &#123;<br>        L.data[j - <span class="hljs-number">1</span>] = L.data[j];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-built_in">visit</span>(L.data[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocateChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> em)</span> </span>&#123;<br>    <span class="hljs-type">int</span> bitOrder = <span class="hljs-built_in">LocateElem</span>(L, e);<br>    <span class="hljs-keyword">if</span> (bitOrder != <span class="hljs-number">0</span>) &#123;<br>        L.data[bitOrder - <span class="hljs-number">1</span>] = em;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> em)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= L.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L.data[i] = em;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    std::cout&lt;&lt;a&lt;&lt;std::endl;<br>&#125;<br><br><span class="hljs-comment">// 测试模块</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testModule</span><span class="hljs-params">()</span> </span>&#123;<br>    SqList L;<br>    <span class="hljs-built_in">InitList</span>(L);<br><br>    <span class="hljs-comment">// 初始化一些值</span><br>    <span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 插入操作</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ListInsert</span>(L, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;插入成功了\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;插入失败了，i的位置不合法，请检查\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除操作</span><br>    <span class="hljs-type">int</span> e = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ListDelete</span>(L, <span class="hljs-number">2</span>, e)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;删除成功！删除的值是：&quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;删除失败，请检查位序是否正确\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 数组当前长度</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;数组当前长度是多少？&quot;</span> &lt;&lt; <span class="hljs-built_in">ListLength</span>(L) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-comment">// 查找第一个元素是什么？</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetElem</span>(L, <span class="hljs-number">1</span>, e)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;第一个元素是：&quot;</span> &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;查找失败，位置不合法\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找值为3的元素在什么位置</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;第一个值为3的元素在什么位置？&quot;</span> &lt;&lt; <span class="hljs-built_in">LocateElem</span>(L, <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>    <span class="hljs-comment">// 打印输出</span><br>    <span class="hljs-built_in">PrintList</span>(L);<br><br>    <span class="hljs-comment">// 测试改模块功能是否正常</span><br>    <span class="hljs-type">int</span> e1 = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> em1 = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> em2 = <span class="hljs-number">7</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;开始测试【改】\n&quot;</span><br>              &lt;&lt; <span class="hljs-string">&quot;第一种方式先按值查找后改值\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">LocateChangeElem</span>(L, e1, em1)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;第一种先按值查找后改值成功啦，改变后的值如下：\n&quot;</span>;<br>        <span class="hljs-built_in">PrintList</span>(L);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;第一种先按值查找后改值失败了，再检查一下吧！\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;第二种先按位序查找后改值\n&quot;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetChangeElem</span>(L, i, em2)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;第二种先按位序查找后改值的方式成功啦，改变后的值如下：\n&quot;</span>;<br>        <span class="hljs-built_in">PrintList</span>(L);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;第二种先按位序查找后改值的方式失败了，再检查一下吧！\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ListEmpty</span>(L)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;顺序表为空！\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;顺序表非空！\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印输出</span><br>    <span class="hljs-built_in">PrintList</span>(L);<br>    <span class="hljs-built_in">ListTraverse</span>(L,visit);<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">testModule</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>      </div>    </div><h4 id="动态分配">动态分配</h4>    <div class="fold">      <div class="fold-title fold-info collapsed" data-toggle="collapse" href="#collapse-dcdac752" role="button" aria-expanded="false" aria-controls="collapse-dcdac752">        <div class="fold-arrow">▶</div>title      </div>      <div class="fold-collapse collapse" id="collapse-dcdac752">        <div class="fold-content">          <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 动态分配顺序表</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitSize 10</span><br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqList</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> *data; <span class="hljs-comment">// 指示动态分配数组的指针</span><br>        <span class="hljs-type">int</span> MaxSize; <span class="hljs-comment">// 顺序表的最大容量</span><br>        <span class="hljs-type">int</span> length; <span class="hljs-comment">// 顺序表当前的长度</span><br><br>        <span class="hljs-built_in">SeqList</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[InitSize]), <span class="hljs-built_in">MaxSize</span>(InitSize), <span class="hljs-built_in">length</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>        ~<span class="hljs-built_in">SeqList</span>() &#123;<br>            <span class="hljs-keyword">delete</span>[] data;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SeqList &amp;L)</span></span>;                         <span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                      <span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Full</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                       <span class="hljs-comment">// 判满</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseSize</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> len)</span></span>;            <span class="hljs-comment">// 动态扩展空间</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>;         <span class="hljs-comment">// 插入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> i)</span></span>;              <span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> e)</span></span>;           <span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>;        <span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroySqList</span><span class="hljs-params">(SeqList &amp;L)</span></span>;                    <span class="hljs-comment">// 销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SeqList &amp;L)</span></span>;                        <span class="hljs-comment">// 清空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                  <span class="hljs-comment">// 获取长度</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span></span>; <span class="hljs-comment">// 查找前驱</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span></span>; <span class="hljs-comment">// 查找后继</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span></span>; <span class="hljs-comment">// 遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintSqList</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                <span class="hljs-comment">// 打印顺序表</span><br><br><span class="hljs-comment">// 实现模块</span><br><br><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SeqList &amp;L)</span> </span>&#123;<br>    L.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[InitSize]; <br>    <span class="hljs-keyword">if</span> (L.data == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L.length = <span class="hljs-number">0</span>;<br>    L.MaxSize = InitSize;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Full</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length &gt;= L.MaxSize;<br>&#125;<br><br><span class="hljs-comment">// 扩展空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseSize</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;开始扩展表存储空间...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-type">int</span> *p = L.data;<br>    L.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[L.MaxSize + len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        L.data[i] = p[i];<br>    &#125;<br>    L.MaxSize += len;<br>    <span class="hljs-keyword">delete</span>[] p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;扩展完成，当前最大容量: &quot;</span> &lt;&lt; L.MaxSize &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 插入</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Full</span>(L)) <span class="hljs-built_in">IncreaseSize</span>(L, InitSize);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length; j &gt;= i; --j) &#123;<br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    L.data[i - <span class="hljs-number">1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> L.data[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e) <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    e = L.data[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; L.length; ++j) &#123;<br>        L.data[j - <span class="hljs-number">1</span>] = L.data[j];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroySqList</span><span class="hljs-params">(SeqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span>[] L.data;<br>    L.data = <span class="hljs-literal">nullptr</span>;<br>    L.length = <span class="hljs-number">0</span>;<br>    L.MaxSize = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SeqList &amp;L)</span> </span>&#123;<br>    L.length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">// 查找前驱</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == cur_e) &#123;<br>            pre_e = L.data[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 查找后继</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == cur_e) &#123;<br>            next_e = L.data[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-built_in">visit</span>(L.data[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintSqList</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L.data == <span class="hljs-literal">nullptr</span> || L.length == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;这是一个空表！&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;开始打印顺序表&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Data[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;] == &quot;</span> &lt;&lt; L.data[i] &lt;&lt; std::endl;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;打印结束！&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试输出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TestPrint</span><span class="hljs-params">(<span class="hljs-type">bool</span> test, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *message)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (test) &#123;<br>        std::cout &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot;成功啦!&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; message &lt;&lt; <span class="hljs-string">&quot;失败啦！&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 访问函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testModule</span><span class="hljs-params">()</span> </span>&#123;<br>    SeqList L;<br>    <span class="hljs-built_in">TestPrint</span>(<span class="hljs-built_in">InitList</span>(L), <span class="hljs-string">&quot;初始化&quot;</span>);<br><br>    <span class="hljs-comment">// 测试插入和打印</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>        <span class="hljs-built_in">TestPrint</span>(<span class="hljs-built_in">ListInsert</span>(L, i, i), <span class="hljs-string">&quot;插入&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">PrintSqList</span>(L);<br><br>    <span class="hljs-comment">// 测试按位查找</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;第3个元素是: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetElem</span>(L, <span class="hljs-number">3</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测试按值查找</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;值为4的元素的位序是: &quot;</span> &lt;&lt; <span class="hljs-built_in">LocateElem</span>(L, <span class="hljs-number">4</span>) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测试删除</span><br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-built_in">TestPrint</span>(<span class="hljs-built_in">ListDelete</span>(L, <span class="hljs-number">2</span>, e), <span class="hljs-string">&quot;删除&quot;</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;删除的元素是: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>    <span class="hljs-built_in">PrintSqList</span>(L);<br><br>    <span class="hljs-comment">// 测试清空</span><br>    <span class="hljs-built_in">ClearList</span>(L);<br>    <span class="hljs-built_in">TestPrint</span>(<span class="hljs-built_in">Empty</span>(L), <span class="hljs-string">&quot;清空&quot;</span>);<br>    <span class="hljs-built_in">PrintSqList</span>(L);<br><br>    <span class="hljs-comment">// 重新插入测试PriorElem和NextElem</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>        <span class="hljs-built_in">ListInsert</span>(L, i, i);<br>    &#125;<br>    <span class="hljs-type">int</span> pre_e, next_e;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">PriorElem</span>(L, <span class="hljs-number">3</span>, pre_e)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;元素3的前驱是: &quot;</span> &lt;&lt; pre_e &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;没有前驱元素&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">NextElem</span>(L, <span class="hljs-number">3</span>, next_e)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;元素3的后继是: &quot;</span> &lt;&lt; next_e &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;没有后继元素&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 测试遍历</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;遍历顺序表: &quot;</span>;<br>    <span class="hljs-built_in">ListTraverse</span>(L, visit);<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测试获取长度</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;顺序表长度是: &quot;</span> &lt;&lt; <span class="hljs-built_in">ListLength</span>(L) &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测试销毁</span><br>    <span class="hljs-built_in">DestroySqList</span>(L);<br>    <span class="hljs-built_in">TestPrint</span>(<span class="hljs-built_in">Empty</span>(L), <span class="hljs-string">&quot;销毁&quot;</span>);<br>    <span class="hljs-built_in">PrintSqList</span>(L);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">testModule</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组合数学——利用差分序列求高次数列前n项和</title>
    <link href="/2024/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97%E6%B1%82%E9%AB%98%E6%AC%A1%E6%95%B0%E5%88%97%E5%89%8Dn%E9%A1%B9%E5%92%8C/"/>
    <url>/2024/07/26/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8%E5%B7%AE%E5%88%86%E5%BA%8F%E5%88%97%E6%B1%82%E9%AB%98%E6%AC%A1%E6%95%B0%E5%88%97%E5%89%8Dn%E9%A1%B9%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1>利用差分序列求高次数列前n项和</h1><p>内容来自《组合数学》第五版（布鲁迪，冯速）。</p><p>这种方式求前n项和某些情况下十分好用，仅仅是自己在想到这个公式将使用时找不到相关资料，决定将书本截图保存至此，不多做解释。</p><p><img src="1.jpg" alt="1"></p><p><img src="2.jpg" alt="2"></p><p><img src="3.jpg" alt="3"></p><p><img src="4.jpg" alt="4"></p><p><img src="5.jpg" alt="5"></p><p><img src="6.jpg" alt="6"></p>]]></content>
    
    
    <categories>
      
      <category>组合数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数列求和</tag>
      
      <tag>组合数学</tag>
      
      <tag>差分序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——算法效率的度量</title>
    <link href="/2024/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F/"/>
    <url>/2024/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1>算法效率的度量</h1><blockquote><p>在这之前，首先介绍算法的五大特性与算法设计的要求。</p><p>五大特性</p><ol><li>有穷性：在有穷操作内完成</li><li>确定性：算法只有唯一的执行路径，每一种输入对应唯一的输出</li><li>可行性：算法中描述的操作都是可以通过已经实现的基本运算执行有限次来实现的。</li><li>输入：零个或多个输入</li><li>输出：一个或多个输出</li></ol><p>算法设计的要求</p><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>效率与低存储量需求</li></ol></blockquote><p>算法效率的度量主要是通过时间维度和空间维度来考量的。</p><ul><li><p>时间维度：是指执行当前算法所消耗的时间，我们通常用<strong>时间复杂度</strong>来描述。</p></li><li><p>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用<strong>空间复杂度</strong>来描述。</p></li></ul><p>通常情况下，算法的时间消耗和空间消耗是二者不可兼得的关系，因此要求我们在编写算法时根据实际情况仔细斟酌。</p><h2 id="一、时间复杂度">一、时间复杂度</h2><p>算法执行时间通过使用该算法编制程序在计算机上所消耗的时间来度量，而度量一个程序的执行时间通常有两种方法。</p><h3 id="（1）事后统计的方法">（1）事后统计的方法</h3><p>目前计算机操作系统所提供的统计方法已经将时间精确到毫秒级，通过比较程序统计的执行时间长短即可比较出算法的时间复杂度。但这种方法有两个缺陷，一是统计时间依赖运行程序来测量，无法通过算法直接得出结果；二是所得时间的统计量依赖于计算机硬件、软件等环境因素，在不同的条件下执行结果并不一致。因此人们更长使用另一种事前估计的方法。</p><h3 id="（2）事前分析估算的方法">（2）事前分析估算的方法</h3><p>同一种算法用不用的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机运行，再或者问题的规模不同，这些因素都会导致算法的执行时间不尽相同，这表明使用绝对的时间量度来衡量算法的效率是不合适的。因此我们需要一种相对的衡量方法，只取决于问题的规模n来决定，或者是，他是问题规模的函数。为了便于比较同一问题的不同算法，通常的做法是，从算法中选取一种对于所研究的问题（或算法类型）来说是基本操作的原操作，以该基本操作重复执行的次数作为算法的时间量度。</p><p>一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，算法的时间量度记为</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p><p>它表示随问题规模n增大，算法执行时间的增长率和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的增长率相同，称作算法的<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。式中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span></span></span></span>的含义是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的数量级。</p><p>算法的时间复杂度不仅仅依赖于问题的规模，还取决于待输入的数据。例如在数组A[0:n-1]中，查找定值K的算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findK</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span> (A[i]==k)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 找不到返回-1</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>语句的频度是指语句重复执行的次数。</p></blockquote><p>对于这个程序来说，若A中没有与K相等的数据，则i++语句频度为n，循环执行n次；若第0个数据为k，则i++频度为0，循环仅执行1次。</p><p>最坏时间复杂度是指在最坏情况下，算法的时间复杂度，对应上述算法中最后一次循环找到k或数组中没有K的情况；最好时间复杂度是指在最好的情况下，算法的时间复杂度，对应上述算法第一次循环便找到了K；平均时间复杂度是指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间。一般总是考虑在<strong>最坏的情况下</strong>的时间复杂度，以保证算法的运行时间不会比它更长。</p><p>对于上面的算法，它的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，即最坏情况下需要遍历整个数组才能找到目标元素，或者确认目标元素不存在。对于一个<strong>无序数组</strong>来说，这已经是最优的线性搜索算法了，因为在最坏情况下你必须检查每个元素才能确定k是否在数组中。但如果这个数组是<strong>有序数组</strong>，则二分查找的算法有着更高的效率。</p><p>以下是一个基于二分查找的优化算法（假设数组是有序的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findK</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = n - <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (A[mid] == k) &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (A[mid] &lt; k) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>二分查找每次迭代将搜索区间减半，每次迭代缩小到原先二分之一的范围，经过<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>次迭代后搜索区间缩小到1，因此时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><h4 id="规则">规则</h4><p>在分析一个程序的时间复杂性时，有两条规则：</p><ol><li>加法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)))</span></span></span></span></li><li>乘法规则：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>×</mo><msub><mi>T</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>×</mo><mi>O</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>×</mo><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=T_1(n) \times T_2(n)=O(f(n)) \times O(g(n))=O(f(n) \times g(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></li></ol><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>程序段<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>程序段<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此上述程序时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)+O(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>程序段<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>程序段<span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此上述程序时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>e</mi><mi>s</mi><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n) /times O(n)=O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">t</span><span class="mord mathnormal">im</span><span class="mord mathnormal">es</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>程序段<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>程序段<span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)&#123;<br>程序段<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此上述程序时间复杂度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>+</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2) + O(n)=O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><p>在进行加法运算时，若将高时间复杂度的算法与低时间复杂度的相加，则取较高的项。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>3</mn></msup><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">f(n)=n^3+n^2+n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>的时间复杂度取<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p><h4 id="常见的渐进时间复杂度">常见的渐进时间复杂度</h4><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>&lt;</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)&lt;O(log n)&lt;O(n)&lt;O(nlogn)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">!)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><h3 id="（3）为什么时间复杂度是-log-n-而不是-log-2-n-呢？">（3）为什么时间复杂度是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>而不是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>呢？</h3><p>在大 O 表示法中，常数因子和常数项通常被省略。这是因为大 O 表示法旨在描述算法复杂度的增长速率，而不是具体的计算步骤或常数倍数。因此， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>    被认为是等价的。</p><h4 id="对数的底数转换">对数的底数转换</h4><p>对数的底数转换公式为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>a</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mi>b</mi></msub><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\log_a(x) = \frac{\log_b(x)}{\log_b(a)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.0573em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.242em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.242em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>如果我们将对数的底数从 2 换成 10 或任何其他常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>，可以看到：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\log_2(n) = \frac{\log(n)}{\log(2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span></span> 是一个常数，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log_2(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\log(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 之间仅仅相差一个常数倍。大 O 表示法忽略这些常数因子，因此：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2(n)) = O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p><h4 id="大-O-表示法的性质">大 O 表示法的性质</h4><blockquote></blockquote><p>大 O 表示法关心的是当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 变得非常大时，算法的增长趋势。因此，常数因子和低阶项都可以忽略。例如，以下所有时间复杂度都是等价的：</p><blockquote></blockquote><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>2</mn><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>3</mn><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>+</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(3\log(n) + 5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">3</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span></li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log_2(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.207em;"><span style="top:-2.4559em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2441em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></li></ul><p>它们都简化为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span>。</p><h2 id="二、空间复杂度">二、空间复杂度</h2><p>类似于时间复杂度，我们用空间复杂度作为算法所需存储空间的量度，记作</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)=O(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span></span></p><p>其中n为问题的规模（或大小）。一个上机执行的程序除了需要存储空间来寄存本身所用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输人数据所占空间只取决于问题本身，和算法无关，则只需要分析除输人和程序之外的额外空间，否则应同时考虑输人本身所需空间（和输入数据的表示形式有关）。若额外空间相对于输人数据量来说是常数，则称此算法为原地工作，后面讨论的有些排序算法就属于这类。又如果所占空间量依赖于特定的输入，则除特别指明外，均按<strong>最坏情况</strong>来分析。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
      <tag>大O表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构——线性表</title>
    <link href="/2024/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2024/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1>线性表</h1><blockquote><p>线性结构的特点是：在数据元素的非空有限集中，(1)存在唯一的一个被称做“第一个”的数据元素；(2)存在唯一的一个被称做“最后一个”的数据元素；(3)除第一个之外，集合中的每个数据元素均只有一个前驱；(4)除最后一个之外，集合中每个数据元素均只有一个后继。</p></blockquote><h2 id="一、线性表的基本概念">一、线性表的基本概念</h2><h3 id="（一）线性表的定义">（一）线性表的定义</h3><p>线性表是由n个具有相同数据类型的数据元素组成的有限序列。其中n&gt;=0，n为表长，当n为0时线性表是一个空表，若用L命名线性表，则其一般表示为：</p><center>L=(a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>i</sub>, …, a<sub>n</sub>)</center><p>式中，a<sub>1</sub>是唯一的“第一个”数据元素，又称表头元素；a<sub>n</sub>是唯一的“最后一个”数据元素，又称表尾元素。除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外,每个元素有且仅有一个直接后继（“直接前驱”和“前驱”、“直接后继”和“后继”通常被视为同义词）。</p><p>在稍复杂的线性表中，一个数据元素可以由若干个<strong>数据项</strong>(item)组成。在这种情况下，常把数据元素称为<strong>记录</strong>(record)，含有大量记录的线性表又称<strong>文件</strong>(file)。</p><p>以上就是线性表的逻辑特性,这种线性有序的逻辑结构正是线性表名字的由来。</p><p>由此,我们得出线性表的特点如下:</p><ul><li>表中元素的个数有限。</li><li>表中元素具有逻辑上的顺序性，表中元素有其先后次序。</li><li>表中元素都是数据元素，每个元素都是单个元素。</li><li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。</li><li>表中元素具有抽象性，即仅讨论元素间的逻辑关系,而不考虑元素究竟表示什么内容。</li></ul><h3 id="（二）线性表的基本操作">（二）线性表的基本操作</h3><p>抽象数据类型线性表的定义如下：</p><pre><code class="hljs"><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xquery">ADT List &#123;<br>    数据对象：D = &#123; a<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>i<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span> | a<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>i<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span> ∈ ElemSet, i = <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n, n&gt;=<span class="hljs-number">0</span> &#125;<br>    数据关系：R1 = ( &lt;a<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>i-1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span>, a<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>i<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span>&gt; | a<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>i-1<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span>,a<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>i<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span></span> ∈ D, i = <span class="hljs-number">2</span>,…,n)<br>    基本操作：<br>    InitList( &amp;L )<br>        操作结果：构造一个空的线性表L。<br>    DestroyList( &amp;L )<br>        初始条件：线性表L已存在。<br>        操作结果：销毁线性表L。<br>    ClearList( &amp;L )<br>        初始条件：线性表L已存在。<br>        操作结果：将L重置为空表。<br>    PrintList( L )<br>        初始条件：线性表L已存在。<br>        操作结果：按前后顺序输出线性表L的所有元素。<br>    ListEmpty( L )<br>        初始条件：线性表L已存在。<br>        操作结果：若L为空表，则返回True，否则返回False。<br>    Listlength( L )<br>        初始条件：线性表L已存在。<br>        操作结果：返回L中数据元素个数。<br>    GetElem( L, i, &amp;e )<br>        初始条件：线性表L已存在，<span class="hljs-number">1</span>&lt;=i&lt;=ListLength(L)。<br>        操作结果：用e返回L中第i个数据元素的值。<br>    LocateElem( L, e,<span class="hljs-built_in"> compare</span>() )<br>        初始条件：线性表L已存在<span class="hljs-built_in">，compare</span>()是数据元素判定函数。<br>        操作结果：返回L中第<span class="hljs-number">1</span>个与e满足关<span class="hljs-built_in">系compare</span>()的数据元素的位序。若这样的数据元素不存在，则返回值为<span class="hljs-number">0</span>。<br>    PriorElem( L, cur_e, &amp;pre_e )<br>        初始条件：线性表L已存在。<br>        操作结果：若cur_e是L的数据元素，且不是第一个，则用则用pre_e来返回他的前驱，否则操作失败，pre_e无定义。<br>    NextElem( L, cur_e, &amp;pre_e )<br>        初始条件：线性表L已存在。<br>        操作结果：若cur_e是L的数据元素，且不是最后一个，则用则用next_e来返回他的后继，否则操作失败，next_e无定义。<br>    ListInsert( &amp;L, i, e )<br>        初始条件：线性表L已存在，<span class="hljs-number">1</span>&lt;=i&lt;=ListLength(L)+<span class="hljs-number">1</span>。<br>        操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="hljs-number">1</span>。<br>    ListDelete( &amp;L, i, &amp;e )<br>        初始条件：线性表L已存在且非空，<span class="hljs-number">1</span>&lt;=i&lt;=ListLength(L)。<br>        操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减<span class="hljs-number">1</span>。<br>    ListTraverse( L, visit() )<br>        初始条件：线性表L已存在。<br>        操作结果：依次对L的每个数据元素调用函数visit()。一旦visit()失败，则操作失败。<br>&#125; ADT List<br></code></pre></td></tr></table></figure></code></pre><p>除了以上操作，还可以有一些更复杂的操作，例如拆分、合成与复制线性表。</p><h2 id="二、线性表的实现">二、线性表的实现</h2><h3 id="（一）顺序存储">（一）顺序存储</h3><h4 id="1-顺序表的定义">1.顺序表的定义</h4><p>线性表的顺序存储指的是用一组地址连续的存储单元依次存储线性表的数据元素，又称为顺序表，因此表中逻辑上相邻的两个元素在物理位置上也连续，正因为这一点，而且线性表中各元素属于同一类型，因此，顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的数据结构。通常用高级程序设计语言的数组来描述线性表的顺序存储结构。</p><h4 id="2-顺序表的实现">2.顺序表的实现</h4><p>在C++语言中，我们可以使用一维数组作为顺序表的存储结构，但是同样是数组我们也有两种不同的实现方式，分别是静态分配与动态分配。对数组进行静态分配时，由于数组的大小和空间已经固定，所以空间一旦被占满，再加入新数据就会发生溢出，进而导致程序崩溃。而进行动态分配则可以避免这一问题，存储数组的空间大小是在程序执行过程中可以自由调整的，通过内存分配语句来进行控制，因此一旦空间占满，就另外开辟一块更大的存储空间，将原表中的元素全部拷贝到新空间，从而达到扩充数组存储空间的目的，而不需要一次性地为数组划分所有空间。</p><blockquote><p>后续所有代码均采用C++实现，并为了保持跟课本上定义的抽象数据类型的基本操作一致，仅仅会使用部分C++特性。比如这一节我使用类来定义顺序表的数据结构，却将数据操作方法定义在类外，完全可以定义在类内进行，且更推荐将所有相关操作定义在同一类内而不是使用引用的方式。</p></blockquote><h5 id="静态分配">静态分配</h5><blockquote><p><a href="https://blog.cxhap.top/2024/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/#%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D">完整代码</a></p></blockquote><p>首先来看一下静态分配顺序表的数据结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxSize 10 <span class="hljs-comment">// 顺序表的最大长度</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SqList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> data[MaxSize]; <span class="hljs-comment">// 实际的存储结构，采用数组存储</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 记录顺序表的当前长度</span><br><br>    <span class="hljs-built_in">SqList</span>() &#123;<br>        length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MaxSize; ++i) &#123;<br>            data[i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 将数组内的每个数值初始化为0,否则访问时为随机值，即脏数据</span><br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可见，在创建<code>SqList</code>这个数据结构时已经完成了内存分配，顺序表长度不可改变，并且由于数组可以通过数组下标来访问每个位置的元素，实现了顺序表随机存取的特性。但需要注意C++数组下标从0开始。</p><p>下面是函数声明部分，定义了顺序表各个函数，这里不多做解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>;                           <span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span></span>;                        <span class="hljs-comment">// 销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span></span>;                          <span class="hljs-comment">// 重置为空表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span></span>;                    <span class="hljs-comment">// 打印</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span></span>;                    <span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span></span>;                    <span class="hljs-comment">// 获取长度</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>;       <span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> e)</span></span>;             <span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span></span>; <span class="hljs-comment">// 查找前驱</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span></span>; <span class="hljs-comment">// 查找后继</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>;           <span class="hljs-comment">// 插入</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>;          <span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span></span>; <span class="hljs-comment">// 遍历</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocateChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> em)</span></span>;    <span class="hljs-comment">// 先按值查找后改值</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> em)</span></span>;       <span class="hljs-comment">// 先按位序查找后改值</span><br></code></pre></td></tr></table></figure><p>下面是顺序表的初始化，销毁与清空。初始化在新建<code>SqList</code>时其实已经发生，而销毁操作会自动进行，因此无需手动销毁，清空操作是将长度置0然后将数组元素全部清空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现模块</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    L.length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-comment">// 静态分配，无需显式销毁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SqList &amp;L)</span> </span>&#123;<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MaxSize; ++i) &#123;<br>        L.data[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是顺序表的打印，即数据表的元素存储在数组的前<code>length</code>位置上，只需循环访问即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;开始打印顺序表\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Data[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]==&quot;</span> &lt;&lt; L.data[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;打印结束！\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是判空与获取长度函数，只需要获取顺序表<code>length</code>变量的值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>GetElem</code>函数获取顺序表中第i个元素，这里的i是从1开始的，因此需要首先检测要求获取的值是否在范围内，小于1以及大于顺序表长度的值都是不允许的。如果查找失败则返回<code>false</code>，查找成功则返回<code>true</code>并且将查找到的值用e返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e = L.data[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LocateList</code>函数获取表中第一次出现e元素的位置，返回值为元素e在表中的位序，如果没找到则返回<code>0</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == e)<br>            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 返回位序</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 未找到返回0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>PriorElem</code>和<code>NextElem</code>函数在顺序表中查找元素e，若找到元素e且它有前一个或后一个元素，则用<code>pre_e</code>或<code>next_e</code>返回其相邻的上一个元素或下一个元素并且返回值为<code>true</code>，否则返回值为<code>false</code>并且<code>pre_e</code>和<code>next_e</code>不代表任何值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == cur_e) &#123;<br>            pre_e = L.data[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (L.data[i] == cur_e) &#123;<br>            next_e = L.data[i + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ListInsert</code>与<code>ListDelete</code>分别用于向顺序表插入元素和删除元素，需要注意的是，由于顺序表中元素的逻辑顺序和物理顺序保持一致，因此在进行插入操作时，需要将被插入位置后面的所有元素全部后移；在进行删除操作时，需要将被删除元素后面的的全部元素向前移动一位。移动操作的时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span> || L.length &gt;= MaxSize)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length; j &gt;= i; --j) &#123;<br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    L.data[i - <span class="hljs-number">1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    e = L.data[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; L.length; ++j) &#123;<br>        L.data[j - <span class="hljs-number">1</span>] = L.data[j];<br>    &#125;<br>    L.length--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ListTraverse</code>函数用于使用指定的函数访问顺序表的各元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123;<br>        <span class="hljs-built_in">visit</span>(L.data[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如有个简单的函数<code>visit</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>    std::cout&lt;&lt;a&lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>可通过下面的方式调用<code>visit</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ListTraverse</span>(L,visit);<br></code></pre></td></tr></table></figure><p><code>LocateChangeElem</code>与<code>GetChangeElem</code>分别是两种改元素值的方式，代码比较简单，先定位后修改，代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LocateChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> e, <span class="hljs-type">int</span> em)</span> </span>&#123;<br>    <span class="hljs-type">int</span> bitOrder = <span class="hljs-built_in">LocateElem</span>(L, e);<br>    <span class="hljs-keyword">if</span> (bitOrder != <span class="hljs-number">0</span>) &#123;<br>        L.data[bitOrder - <span class="hljs-number">1</span>] = em;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetChangeElem</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> em)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= L.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L.data[i] = em;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="动态分配">动态分配</h5><blockquote><p><a href="https://blog.cxhap.top/2024/07/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E6%BA%90%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D">完整代码</a></p></blockquote><p>相较于静态分配，动态分配顺序表的实现要稍显复杂，顺序表的数据结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> InitSize 10</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SeqList</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> *data; <span class="hljs-comment">// 指示动态分配数组的指针</span><br>    <span class="hljs-type">int</span> MaxSize; <span class="hljs-comment">// 顺序表的最大容量</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 顺序表当前的长度</span><br><br>    <span class="hljs-built_in">SeqList</span>() : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[InitSize]), <span class="hljs-function">MaxSiz<span class="hljs-title">e</span><span class="hljs-params">(InitSize)</span>, <span class="hljs-title">length</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span> </span>&#123;&#125;<br>    ~<span class="hljs-built_in">SeqList</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数声明如下，由于<code>LocateChangeElem</code>与<code>GetChangeElem</code>实现方法没有什么不同，这里不再赘述。其中<code>IncreaseSize</code>函数起到扩展动态分配顺序表的空间的作用，下面我仅介绍与上述实现不同的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SeqList &amp;L)</span></span>;                         <span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Empty</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                      <span class="hljs-comment">// 判空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Full</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                       <span class="hljs-comment">// 判满</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseSize</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> len)</span></span>;            <span class="hljs-comment">// 动态扩展空间</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span></span>;         <span class="hljs-comment">// 插入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> i)</span></span>;              <span class="hljs-comment">// 按位查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> e)</span></span>;           <span class="hljs-comment">// 按值查找</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListDelete</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>;        <span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroySqList</span><span class="hljs-params">(SeqList &amp;L)</span></span>;                    <span class="hljs-comment">// 销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(SeqList &amp;L)</span></span>;                        <span class="hljs-comment">// 清空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                  <span class="hljs-comment">// 获取长度</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PriorElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;pre_e)</span></span>; <span class="hljs-comment">// 查找前驱</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">NextElem</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">int</span> cur_e, <span class="hljs-type">int</span> &amp;next_e)</span></span>; <span class="hljs-comment">// 查找后继</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListTraverse</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L, <span class="hljs-type">void</span> (*visit)(<span class="hljs-type">int</span>))</span></span>; <span class="hljs-comment">// 遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintSqList</span><span class="hljs-params">(<span class="hljs-type">const</span> SeqList &amp;L)</span></span>;                <span class="hljs-comment">// 打印顺序表</span><br></code></pre></td></tr></table></figure><p>初始化函数如下，由于采用动态分配内存的方式，顺序表必须手动销毁。在这里我采用的C++类的方式编写的数据结构，因此使用析构函数<code>~SeqList()</code>进行顺序表的销毁。当然，按照前文方法定义，如果非要进行自行销毁的话也是可以的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 初始化</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">InitList</span><span class="hljs-params">(SeqList &amp;L)</span> </span>&#123;<br>    L.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[InitSize]; <br>    <span class="hljs-keyword">if</span> (L.data == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    L.length = <span class="hljs-number">0</span>;<br>    L.MaxSize = InitSize;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">// 销毁</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestroySqList</span><span class="hljs-params">(SeqList &amp;L)</span> </span>&#123;<br>    <span class="hljs-keyword">delete</span>[] L.data;<br>    L.data = <span class="hljs-literal">nullptr</span>;<br>    L.length = <span class="hljs-number">0</span>;<br>    L.MaxSize = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>IncreaseSize</code>是动态分配顺序表的核心函数，首先分配一个指针p指向原先顺序表的内存数据，其次分配增加之后的存储空间，然后将原内存数据复制进新空间，最后回收原先分配的内存，即完成了扩展空间操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 扩展空间</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">IncreaseSize</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;开始扩展表存储空间...&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-type">int</span> *p = L.data;<br>    L.data = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[L.MaxSize + len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; ++i) &#123; <span class="hljs-comment">// 复制数据</span><br>        L.data[i] = p[i];<br>    &#125;<br>    L.MaxSize += len;<br>    <span class="hljs-keyword">delete</span>[] p;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;扩展完成，当前最大容量: &quot;</span> &lt;&lt; L.MaxSize &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ListInsert</code>与静态分配的最大区别在于，当顺序表空间不足时会自动完成内存扩展，再进行插入操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 插入</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ListInsert</span><span class="hljs-params">(SeqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Full</span>(L)) <span class="hljs-built_in">IncreaseSize</span>(L, InitSize);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length; j &gt;= i; --j) &#123;<br>        L.data[j] = L.data[j - <span class="hljs-number">1</span>];<br>    &#125;<br>    L.data[i - <span class="hljs-number">1</span>] = e;<br>    L.length++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其余代码与上述静态分配顺序表相同，不进行列举。</p><h3 id="（二）链式存储">（二）链式存储</h3><h2 id="三、线性表的应用">三、线性表的应用</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>数据结构</tag>
      
      <tag>线性表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统——操作系统的发展历程</title>
    <link href="/2024/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/"/>
    <url>/2024/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>操作系统的发展历程</h1><h2 id="一、未配置操作系统的计算机系统">一、未配置操作系统的计算机系统</h2><p>从1945年诞生的第一台计算机，到50年代中期的计算机，都属于<strong>第一代计算机</strong>。这时还未出现OS，对计算机的全部操作都是由用户采取人工方式进行的。</p><h3 id="1-人工操作方式">1.人工操作方式</h3><p>早期的操作方式是由程序员将事先己穿孔的纸带(或卡片)，装入纸带输入机(或卡片输入机)。再启动它们将纸带(或卡片)上的程序和数据输入计算机，然后启动计算机运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点：</p><ol><li>用户独占全机，即一台计算机的全部资源由上机用户所独占。</li><li>CPU 等待人工操作。当用户进行装带(卡)卸带(卡)等人工操作时，CPU 及内存等资源是空闲的。<br>可见，人工操作方式严重降低了计算机资源的利用率，此即所谓的人机矛盾。虽然CPU的速度在迅速提高，但IO设备的速度却提高缓慢，这使CPU与IO设备之间速度不匹配的矛盾更加突出。为此，曾先后出现了通道技术，缓冲技术，然而都未能很好地解决上述矛盾，直至后来引入了脱机输入/输出技术，才获得了相对较为满意的结果。</li></ol><h3 id="2-脱机输入-输出（Off-line-I-O）方式">2.脱机输入/输出（Off-line I/O）方式</h3><p>在输入时，事先将程序和数据装入纸带输入机，在一台外围机的控制下将纸带上的数据和程序输入磁带，当CPU需要这些数据时再将数据从磁带调入，输出时同理，先将数据输出到磁带上，再由外围机控制进行输出，从而提升了I/O速度。</p><h2 id="二、单道批处理系统（Single-Batch-Processing-System）">二、单道批处理系统（Single Batch Processing System）</h2><p>1950年代中期进入第二代晶体管计算机。单道批处理系统是一组监控程序，为了实现对作业的连续控制，需要把一批作业以脱机的方式输入到磁带上，并在监控程序的控制下，每当一项作业完成后，程序将控制权交给监控程序，监控程序自动调入磁带上下一个作业，直至磁带上的所有作业被全部完成，从而使这批作业能一个接一个的被处理，减少空闲等待时间。虽然作业是一批一批完成的，但是在内存中始终只保持一项作业。</p><h3 id="特征">特征</h3><ol><li>自动性。自动逐个运行一批作业。</li><li>顺序性。调入内存的先后顺序与程序在磁带中的顺序一致。</li><li>单道性。内存中只存在一个程序，在执行完成或出现异常后装入后继程序运行。</li></ol><h3 id="缺点">缺点</h3><p>在运行时如果遇到耗时的I/O操作，则CPU需要等待I/O完成之后才能完成继续的执行，这严重拖累了Cpu的运行，并且内存中仅装入一道程序必然会造成内存的浪费，因此便有了多道批处理系统。</p><h2 id="三、多道批处理系统（Multiprogrammed-Batch-Processing-System）">三、多道批处理系统（Multiprogrammed Batch Processing System）</h2><p>1960年代中期诞生的第一台小规模集成电路计算机IBM 360（第三代计算机系统）在体积、功耗、速度和可靠性上有了显著改善，取得了显著成功，同时计算机系统进入了更多工作领域。OS/360是第一个能运行多道程序的批处理系统。多道批处理系统相较于单道批处理系统改变在于在内存中同时装载多项作业，在该系统中，用户所提交的作业先存放在外存上，并排成“后备队列”，然后由作业调度程序按照一定的算法从后备队列中选择若干个作业调入内存，使他们共享CPU和其他资源。由于内存中装在多个程序，因此在程序运行过程中遇到I/O等需要等待的耗时操作时，可以调度另一程序执行，使多道程序轮流交替执行，从而使CPU保持忙碌状态，提高运行效率。由于需要完成CPU、内存与I/O设备等资源的分配调度等工作，因此多道程序的设计与实现复杂很多。</p><h3 id="特点">特点</h3><ol><li>多道。内存中存放多个程序。</li><li>宏观上并行。由于任务切换着执行，并且切换时间很短，因此在宏观上各程序并行执行。</li><li>微观上串行。由于CPU只有一个，因此只能同时运行一个程序，各程序间交替执行。</li></ol><h3 id="优点与缺点">优点与缺点</h3><ol><li>资源利用率高</li><li>系统吞吐量大</li><li>平均周转时间长</li><li>无交互能力</li></ol><h3 id="需要解决的问题">需要解决的问题</h3><ol><li>处理机争用问题</li><li>内存分配和保护的问题</li><li>I/O设备分配问题</li><li>文件的组织和管理问题</li><li>作业的组织和管理问题</li><li>用户与系统的接口问题</li></ol><p>若在计算机系统中增加处理以上问题的一组软件，这组软件应包括：能有效管理和组织四大资源的软件、合理地对各类作业进行调度和控制他们运行的软件以及方便用户使用计算机的软件。正是这样一组软件构成了操作系统。因此操作系统被定义为：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合。</p><h2 id="四、分时系统-Time-Sharing-Operating-System，TOS">四、分时系统(Time-Sharing Operating System，TOS)</h2><p>所谓分时技术，是指把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。分时操作系统是指多个用户通过终端同时共享一台主机（共享主机），这些终端连接在主机上，用户可以同时与主机进行交互操作而互不干扰。因此，实现分时系统最关键的问题是如何使用户能与自己的作业进行交互，即当用户在自己的终端上键入命令时，系统应能及时接收并及时处理该命令，再将结果返回用户（人机交互）。分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。</p><h3 id="主要特征">主要特征</h3><ol><li>同时性。同时性也称多路性,指允许多个终端用户同时使用一台计算机,即一台计算机与若干台终端相连接,终端上的这些用户可以同时或基本同时使用计算机。</li><li>交互性。用户能够方便地与系统进行人机对话,即用户通过终端采用人机对话的方式直接控制程序运行,与同程序进行交互。</li><li>独立性。系统中多个用户可以彼此独立地进行操作,互不干扰,单个用户感觉不到别人也在使用这台计算机,好像只有自己单独使用这台计算机一样。</li><li>及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务。</li></ol><h2 id="五、实时系统">五、实时系统</h2><p>实时系统是指系统能及响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p><h3 id="实时系统的类型">实时系统的类型</h3><ol><li>工业（武器）控制系统</li><li>信息查询系统</li><li>多媒体系统</li><li>嵌入式系统</li></ol><h3 id="实时任务的类型">实时任务的类型</h3><h4 id="周期性实时任务和非周期性实时任务">周期性实时任务和非周期性实时任务</h4><p>周期性实时任务按指定周期循环执行，非周期性实时任务执行伴随着截止时间，截止时间分为：开始截至时间（收到请求后最迟开始执行时间）、完成截止时间（在指定时间内完成任务）</p><h4 id="硬实时任务和软实时任务">硬实时任务和软实时任务</h4><p>硬实时任务(HIrd Real-time Task，HRT)是指系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果。用于工业和武器控制的实时系统，通常它所执行的是硬实时任务。软实时任务(Soft Real-time Task，SRT)也联系着一个截止时间，但并不严格，若偶尔错过了任务的截止时间，对系统产生的影响也不会太大。诸如用于信息查询系统和多媒体系统中的实时系统，通常是软实时任务。</p><h3 id="特征-2">特征</h3><ol><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性（简单交互性）</li><li>可靠性</li></ol><h2 id="六、网络操作系统和分布式计算机系统">六、网络操作系统和分布式计算机系统</h2><p>网络操作系统将计算机网络中的各台计算机有机结合，提供一种统一、经济而高效的使用方式，实现计算机之间的数据互传。其主要特点是网络中资源的共享以及计算机之间的通信。</p><p>分布式计算机系统由多台计算机组成，并满足以下条件：系统中任意两台计算机可以通过通信方式交换信息；系统中的每台计算机地位平等，没有主机或从机之分；每台计算机上的资源对所有用户开放共享；系统中的任意计算机可以组成子系统，并具备重构能力；任何任务都可以分布在多台计算机上，由它们并行工作、协同完成。用于管理这种系统的操作系统被称为分布式操作系统。其主要特点是分布性和并行性。与网络操作系统不同的是，分布式操作系统中的多台计算机能够协同完成同一任务。</p><h2 id="七、微机操作系统">七、微机操作系统</h2><p>随着计算机技术与超大规模集成电路（VLSI）的发展，计算机系统同时朝着大型化与小型化发展，8080与Z80等芯片的发布，更为廉价的微型机逐渐走向大众视野中，最早诞生的微机操作系统是配置在8位微机上的CP/M。后来逐渐出现字长16位、32位、64位的微机和微机操作系统。</p><h3 id="（1）单用户单任务操作系统">（1）单用户单任务操作系统</h3><p>单用户单任务操作系统是指只允许一个用户上机，且只允许用户程序作为一个任务运行，这是最简单的微机操作系统，主要配置在8位和16位微机上，最有代表性的单用户单任务微机操作系统是CP/M和MS-DOS。</p><h4 id="CP-M">CP/M</h4><p>1974年第一代通用8位微处理机芯片Intel 8080出现后的第二年，Digital Research公司就开发出带有软盘系统的8位微机操作系统。1977年Digital Research公司对CP/M进行了重写，使其可配置在以Intel 8080、8085、Z80等8位芯片为基础的多种微机上。1979年又推出带有硬盘管理功能的CP/M 2.2版本。由于CP/M具有较好的体系结构，可适应性强，可移植性以及易学易用等优点，使之在8位微机中占据了统治地位。</p><h4 id="MS-DOS">MS-DOS</h4><p>1981年IBM公司首次推出了IBM-PC个人计算机(16位微机)，在微机中采用了微软公司开发的MS-DOS(Disk Operating System)操作系统，该操作系统在CP/M的基础上进行了<br>较大的扩充，使其在功能上有很大的提高。1983年IBM推出 PC/AT(配有Intel 80286芯片)，相应地微软又开发出 MS-DOS 2.0版本，它不仅能支持硬盘设备，还采用了树形目录结构的文件系统。1987年又宣布了MS-DoS 3.3版本。从MS-DoS 1.0到3.3为止的版本都属于单用户单任务操作系统，内存被限制在640KB。从1989到1993年又先后推出了多个MS-DOS版本，它们都可以配置在Intel80386、80486等32位微机上。从80年代到90年代初，由于MS-DOS性能优越受到当时用户的广泛欢迎，成为事实上的16位单用户单任务操作系统标准。</p><h3 id="（2）单用户多任务操作系统">（2）单用户多任务操作系统</h3><p>单用户多任务操作系统的含义是，只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行，从而有效地改善了系统的性能。目前在32位微机上配置的操作系统，基本上都是单用户多任务操作系统。其中最有代表性的是由微软公司推出了Windows。1985年和1987年微软公司先后推出了Windows 1.0和Windows 2.0版本操作系统，由于当时的硬件平台还只是16位微机，对10和2.0版本不能很好地支持。1990年微软公司又发布了Windows 3.0版本，随后又宣布了Windows 3.1版本，它们主要是针对386和486等32位微机开发的，它较之以前的操作系统有着重大的改进，引入了友善的图形用<br>户界面，支持多任务和扩展内存的功能。使计算机更好使用，从而成为386和486等微机的主流操作系统。<br>1995年微软公司推出了Windows 95，它较之以前的Windows 3.1有许多重大改进，采用了全32位的处理技术，并兼容以前的16位应用程序，在该系统中还集成了支持Internet的网络功能。1998年微软公司又推出了Windows 95的改进版Windows 98，它已是最后一个仍然兼容以前的16位应用程序的Windows。其最主要的改进是把微软公司自己开发的Internet浏览器整合到系统中，大大方便了用户上网浏览：另一个改进是增加了对多媒体的支持。2001年微软又发布了Windows XP，同时提供了家用和商业工作站两种版本，在此后相当长的一段时间，成为使用最广泛的个人操作系统之一。在开发上述 Windows操作系统的同时，微软公司又开始对网络操作系统 Windows NT进行开发，它是针对网络开发的操作系统，在系统中融入许多面向网络的功能，从2006年后推出的一系列内核版本号为NT6.X的桌面及服务器操作系统，包括Windows Vista，Windows Server 2008、Windows 7、Windows Server 2008 R2、Windows 8和Windows Server 2012等，这里就不对它们进行介绍。</p><h3 id="（3）多用户多任务操作系统">（3）多用户多任务操作系统</h3><p>多用户多任务操作系统的含义是，允许多个用户通过各自的终端，使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量。在大、中和小型机中所配置的大多是多用户多任务操作系统，而在32位微机上，也有不少配置的是多用户多任务操作系统，其中最有代表性的是UNIX OS。UNIX OS是美国电报电话公司的Bell实验室在1969~1970年期间开发的，1979年推出来的UNIX V.7已被广泛应用于多种中小型机上。随着微机性能的提高，人们又将UNIX移植到微机上。在1980年前后，将UNIX第7版本移植到Motorola公司的MC 680xx微机上，后来又将UNIX V7.0版本进行简化后，移植到Intel 8080上，把它称为Xenix。现在最有影响的两个能运行在微机上的UNIX 操作系统变形是Solaris OS 和Linux OS。<br>(1)Solaris OS：SUN公司于1982年推出的SUN OS 1.0，是一个运行在MOTOROLA 680x0平台上的UNIX OS，在1988年宣布的SUN OS 4.0，把运行平台从早期的MOTOROLA 680x0平台迁移到SPARC平台，并开始支持Intel公司的Intel 80x86;1992年SUN发布了Solaris 2.0。从1998年开始，Sun公司推出64位操作系统Solaris 2.7和2.8，这几款操作系统在网络特性、互操作性、兼容性以及易于配置和管理方面均有很大的提高。<br>(2)Linux OS:Linux是UNIX的一个重要变种，最初是由芬兰学生Linus Torvalds针对Intel 80386开发的，1991年，在Internet网上发布第一个Linux版本，由于源代码公开，因此有很多人通过Internet 与之合作，使Linux 的性能迅速提高，其应用范围也日益扩大，相应地，源代码也急剧膨胀，此时它已是具有全面功能的UNIX系统，大量在UNIX上运行的软件(包括1000多种实用工具软件和大量网络软件)，被移植到Linux 上，而且可以在主要的微机上运行，如Inel 80X86 Pentium等。</p><h2 id="按时间排序">按时间排序</h2><h3 id="大型机操作系统的发展历程">大型机操作系统的发展历程</h3><h4 id="1950s-1960s">1950s-1960s</h4><ul><li><strong>GM-NAA I/O</strong>: 1956年，通用汽车为IBM 701计算机开发的操作系统，是最早的商用操作系统之一。</li><li><strong>SHARE Operating System (SOS)</strong>: 由IBM用户组织SHARE在1960年开发，用于IBM 7090计算机。</li><li><strong>BESYS</strong>: 由贝尔实验室开发，用于科学计算，使用于1950年代末到1960年代中期。</li><li><strong>IBSYS</strong>: IBM在1960年代初为其7090和7094大型计算机开发的操作系统，支持批处理和多道程序设计。</li></ul><h4 id="1960s-1970s">1960s-1970s</h4><ul><li><strong>OS/360</strong>: 1964年推出，专为IBM System/360计算机系列设计。支持批处理、多编程和分时系统，成为商业领域的重要操作系统。</li><li><strong>CP/CMS</strong>: 1967年推出，是第一个成功的虚拟机操作系统，支持在单台物理机器上运行多个操作系统实例。</li><li><strong>TSS/360</strong>: 为System/360开发的时间共享系统，但由于可靠性问题未能广泛应用。</li></ul><h4 id="1970s-1980s">1970s-1980s</h4><ul><li><strong>VM/370</strong>: CP/CMS的后继者，1972年推出，为System/370系列提供虚拟机支持。</li><li><strong>MVS (Multiple Virtual Storage)</strong>: 1974年推出，是OS/360的演进版本，增加了对虚拟内存的支持，成为IBM大型机的主要操作系统之一。</li><li><strong>DOS/360</strong>: 为中小型System/360计算机设计，1966年推出，适用于磁盘驱动器有限的环境。</li></ul><h4 id="1980s-2000s">1980s-2000s</h4><ul><li><strong>MVS/XA (Extended Architecture)</strong>: 1981年推出，扩展了MVS的体系结构，支持更多的物理和虚拟内存。</li><li><strong>MVS/ESA (Enterprise Systems Architecture)</strong>: 1985年推出，进一步增强了MVS的功能。</li><li><strong>OS/390</strong>: 1996年推出，将MVS与其它系统软件整合，提供更全面的企业级解决方案。</li><li><strong>z/OS</strong>: 2000年推出，现代化的64位操作系统，兼容以前的MVS和OS/390应用程序。</li><li><strong>Linux on IBM Z</strong>: 1999年开始，IBM在大型机上支持Linux操作系统，使大型机能够运行开源软件，满足新的市场需求。</li></ul><h3 id="小型机操作系统的发展历程">小型机操作系统的发展历程</h3><h4 id="1960s-1970s-2">1960s-1970s</h4><ul><li><strong>RT-11</strong>: 由Digital Equipment Corporation (DEC)在1970年推出，用于PDP-11小型计算机，是早期的实时操作系统。</li><li><strong>UNIX</strong>: 1969年在贝尔实验室开发的分时操作系统，1970年代早期在PDP-7和PDP-11计算机上运行，奠定了现代操作系统的基础。</li></ul><h4 id="1980s">1980s</h4><ul><li><strong>VAX/VMS</strong>: DEC在1977年推出，用于VAX系列小型计算机，支持虚拟内存和分时操作。</li><li><strong>Xenix</strong>: 1980年代初，由微软开发的UNIX版本，运行于多种小型计算机上。</li><li><strong>BSD UNIX</strong>: 1980年代，由加州大学伯克利分校开发的UNIX版本，增加了许多创新功能。</li></ul><h4 id="1990s-2000s">1990s-2000s</h4><ul><li><strong>Windows NT</strong>: 微软在1993年推出的操作系统，支持多处理器和企业级应用，运行在多种硬件平台上。</li><li><strong>Linux</strong>: 1991年由Linus Torvalds发布的开源操作系统，迅速发展成为服务器和桌面应用的重要操作系统。</li></ul><h4 id="2000s至今">2000s至今</h4><ul><li><strong>Windows Server</strong>: 微软为企业服务器市场开发的操作系统，从2000年开始发布多个版本。</li><li><strong>FreeBSD</strong>: 继承自BSD UNIX的开源操作系统，持续发展并广泛应用于服务器和嵌入式系统。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机操作系统</tag>
      
      <tag>笔记</tag>
      
      <tag>发展历程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机科学与技术(081200)考试指南:科目、时间与备考全攻略</title>
    <link href="/2024/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF-081200-%E8%80%83%E8%AF%95%E6%8C%87%E5%8D%97-%E7%A7%91%E7%9B%AE%E3%80%81%E6%97%B6%E9%97%B4%E4%B8%8E%E5%A4%87%E8%80%83%E5%85%A8%E6%94%BB%E7%95%A5/"/>
    <url>/2024/07/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF-081200-%E8%80%83%E8%AF%95%E6%8C%87%E5%8D%97-%E7%A7%91%E7%9B%AE%E3%80%81%E6%97%B6%E9%97%B4%E4%B8%8E%E5%A4%87%E8%80%83%E5%85%A8%E6%94%BB%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1>专业介绍与院校信息</h1><p>见研招网<a href="https://yz.chsi.com.cn/zyk/specialityDetail.do?zymc=%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6%e4%b8%8e%e6%8a%80%e6%9c%af&amp;zydm=081200&amp;cckey=10&amp;ssdm=&amp;method=distribution">计算机科学与技术专业知识库</a>。</p><h1>二级学科</h1><p>不同的学校开设不同的二级学科，但是主要有计算机系统结构、计算机软件与理论、计算机应用技术以及信息安全这四个二级学科。</p><ol><li>计算机系统结构(081201)：先进计算机体系结构、先进微处理器结构、智能计算系统、大数据存储系统、量子计算系统、智能物联网系统、系统软件、高性能计算、云计算、嵌入式计算、边缘计算。</li><li>计算机软件与理论(081202)：计算复杂性理论、算法设计与分析、大数据与智能软件、编译和操作系统、移动计算和智能物联网、新型数据库、图计算、大数据计算、并行与分布式计算、形式化方法和验证技术、程序设计与软件工程学、软件测试、密码学。</li><li>计算机应用技术(081203)：人工智能、大数据分析与管理、机器学习与数据挖掘、知识工程、信息检索与推荐系统、社交网络、生物信息学、数据库技术、多媒体信息处理、区块链技术、多智能体技术、机器人、图形学、计算机视觉、虚拟现实与人机交互、新一代通信技术、智能物联网与应用、智能系统与应用、智慧教育、智慧医疗、计算机辅助设计与制造。</li><li>信息安全(081204)：计算机系统安全、网络安全、信息内容与数据安全、软件安全与验证、区块链技术、隐私保护、信息隐藏与检测、密码理论与应用技术、量子密码学与量子信息安全、计算机病毒与免疫系统、网络管理与风险评估。</li></ol><blockquote><p>以上介绍来自<a href="https://yz1.ustc.edu.cn/sszs_2024/index_8.shtml">ustc硕士研究生计算机与信息学院招生简章</a>。</p></blockquote><h1>初试</h1><h2 id="初试时间">初试时间</h2><p>一般在每年12月末。</p><h2 id="初试科目">初试科目</h2><ol><li>101思想政治理论</li><li>201英语（一）</li><li>301数学（一）</li><li>408计算机学科专业基础<br><a href="https://blog.cxhap.top/2024/07/11/2024-7-11-2024%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80-408-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/">大纲</a></li></ol><h1>复试</h1><h2 id="复试时间">复试时间</h2><p>各大高校自行确定时间，一般从三月份开始，四月底结束。</p><h2 id="复试科目">复试科目</h2><ol><li>面试</li><li>上机</li></ol>]]></content>
    
    
    <categories>
      
      <category>0812计算机考研408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学与技术</tag>
      
      <tag>812</tag>
      
      <tag>硕士研究生考试指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2024计算机学科专业基础(408)考试大纲</title>
    <link href="/2024/07/11/2024-7-11-2024%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80-408-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/"/>
    <url>/2024/07/11/2024-7-11-2024%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E7%A7%91%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80-408-%E8%80%83%E8%AF%95%E5%A4%A7%E7%BA%B2/</url>
    
    <content type="html"><![CDATA[<h1>2024计算机学科专业基础(408)考试大纲</h1><blockquote><p>2024年408考纲为2023年9月公布，是2023年12月参加硕士研究室考试的考纲。2025与2026年考纲将分别于2024年9月以及2025年9月发布。信息收集自互联网。</p></blockquote><h2 id="考试性质">考试性质</h2><p>        计算机学科专业基础考试是为高等院校和科研院所招收计算机科学与技术学科的硕士研究生而设置的具有选拔性质的全国统一入学考试科目。其目的是科学、公正、有效地测试考生掌握计算机科学与技术学科大学本科阶段专业基础知识、基本理论、基本方法的水平和分析问题、解决问题的能力，评价的标准是高等院校计算机科学与技术学科优秀本科毕业生所能达到的及格或及格以上的水平，以利于各高等院校和科研院所择优选拔，确保硕士研究生的招生质量。</p><h2 id="考察目标">考察目标</h2><p>        计算机学科专业基础考试涵盖数据结构、计算机组成原理、操作系统和计算机网络等学科专业基础课程。要求考生系统地掌握上述专业基础课程的基本概念、基本原理和基本方法，能够综合运用所学的基本原理和基本方法分析、判断和解决有关理论问题和实际问题。</p><h2 id="考试形式和试卷结构">考试形式和试卷结构</h2><h3 id="一、试卷满分及考试时间">一、试卷满分及考试时间</h3><p>本试卷满分为150分，考试时间为180分钟。</p><h3 id="二、答题方式">二、答题方式</h3><p>闭卷、笔试。</p><h3 id="三、试卷内容结构">三、试卷内容结构</h3><table><thead><tr><th style="text-align:center">内容</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">数据结构</td><td style="text-align:center">45分</td></tr><tr><td style="text-align:center">计算机组成原理</td><td style="text-align:center">45分</td></tr><tr><td style="text-align:center">操作系统</td><td style="text-align:center">35分</td></tr><tr><td style="text-align:center">计算机网络</td><td style="text-align:center">25分</td></tr></tbody></table><h3 id="四、试卷题型结构">四、试卷题型结构</h3><table><thead><tr><th style="text-align:center">题型</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">单项选择题</td><td style="text-align:center">80分(40题*2分)</td></tr><tr><td style="text-align:center">综合应用题</td><td style="text-align:center">70分(共7题)</td></tr></tbody></table><table><thead><tr><th style="text-align:center">题号</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">41</td><td style="text-align:center">数据结构算法题</td></tr><tr><td style="text-align:center">42</td><td style="text-align:center">数据结构分析题</td></tr><tr><td style="text-align:center">43</td><td style="text-align:center">计算机组成原理</td></tr><tr><td style="text-align:center">44</td><td style="text-align:center">计算机组成原理</td></tr><tr><td style="text-align:center">45</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">46</td><td style="text-align:center">操作系统</td></tr><tr><td style="text-align:center">47</td><td style="text-align:center">计算机网络</td></tr></tbody></table><h2 id="考查内容">考查内容</h2><h3 id="数据结构">数据结构</h3><blockquote><p>参考教材：《数据结构C语言》（严蔚敏版）</p></blockquote><h4 id="考查目标">[考查目标]</h4><ol><li>掌握数据结构的基本概念、基本原理和基本方法。</li><li>掌握数据的逻辑结构、存储结构及基本操作的实现，能够对算法进行基本的时间复杂度和空间复杂度的分析。<a href="https://blog.cxhap.top/2024/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F/">算法效率的度量</a></li><li>能够运用数据结构的基本原理和方法进行问题的分析与求解，具备采用C或C++语言设计和实现算法的能力。</li></ol><h4 id="一、线性表">一、线性表</h4><p><a href="https://blog.cxhap.top/2024/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8/">笔记</a></p><h5 id="（一）线性表的基本概念">（一）线性表的基本概念</h5><h5 id="（二）线性表的实现">（二）线性表的实现</h5><ol><li>顺序存储</li><li>链式存储</li></ol><h5 id="（三）线性表的应用">（三）线性表的应用</h5><h4 id="二、栈、队列和数组">二、栈、队列和数组</h4><h5 id="（一）栈和队列的基本概念">（一）栈和队列的基本概念</h5><h5 id="（二）栈和队列的顺序存储结构">（二）栈和队列的顺序存储结构</h5><h5 id="（三）栈和队列的链式存储结构">（三）栈和队列的链式存储结构</h5><h5 id="（四）多维数组的存储">（四）多维数组的存储</h5><h5 id="（五）特殊矩阵的压缩存储">（五）特殊矩阵的压缩存储</h5><h5 id="（六）栈、队列和数组的应用">（六）栈、队列和数组的应用</h5><h4 id="三、树与二叉树">三、树与二叉树</h4><h5 id="（一）树的基本概念">（一）树的基本概念</h5><h5 id="（二）二叉树">（二）二叉树</h5><ol><li>二叉树的定义及其主要特征</li><li>二叉树的顺序存储结构和链式存储结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li></ol><h5 id="（三）树、森林">（三）树、森林</h5><ol><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li></ol><h5 id="（四）树与二叉树的应用">（四）树与二叉树的应用</h5><ol><li>哈夫曼(Huffman)树和哈夫曼编码</li><li>并查集及其应用</li></ol><h4 id="四、图">四、图</h4><h5 id="（一）图的基本概念">（一）图的基本概念</h5><h5 id="（二）图的存储及基本操作">（二）图的存储及基本操作</h5><ol><li>邻接矩阵</li><li>邻接表法</li><li>邻接多重表，十字链表</li></ol><h5 id="（三）图的遍历">（三）图的遍历</h5><ol><li>深度优先搜索</li><li>广度优先搜索</li></ol><h5 id="（四）图的基本应用">（四）图的基本应用</h5><ol><li>最小（代价）生成树</li><li>最短路径</li><li>拓扑排序</li><li>关键路径</li></ol><h4 id="五、查找">五、查找</h4><h5 id="（一）查找的基本概念">（一）查找的基本概念</h5><h5 id="（二）顺序查找法">（二）顺序查找法</h5><h5 id="（三）分块查找法">（三）分块查找法</h5><h5 id="（四）折半查找法">（四）折半查找法</h5><h5 id="（五）树形查找">（五）树形查找</h5><ol><li>二叉搜索树</li><li>平衡二叉树</li><li>红黑树</li></ol><h5 id="（六）B-树及其基本操作、B-树的基本概念">（六）B 树及其基本操作、B+ 树的基本概念</h5><h5 id="（七）散列-hash-表">（七）散列(hash)表</h5><h5 id="（八）字符串模式匹配">（八）字符串模式匹配</h5><h5 id="（九）查找算法的分析及其应用">（九）查找算法的分析及其应用</h5><h4 id="六、排序">六、排序</h4><h5 id="（一）排序的基本概念">（一）排序的基本概念</h5><h5 id="（二）直接插入排序">（二）直接插入排序</h5><h5 id="（三）折半插入排序">（三）折半插入排序</h5><h5 id="（四）起泡排序-bubble-sort">（四）起泡排序(bubble sort)</h5><h5 id="（五）简单选择排序">（五）简单选择排序</h5><h5 id="（六）希尔排序-shell-sort">（六）希尔排序(shell sort)</h5><h5 id="（七）快速排序">（七）快速排序</h5><h5 id="（八）堆排序">（八）堆排序</h5><h5 id="（九）二路归并排序-merge-sort">（九）二路归并排序(merge sort)</h5><h5 id="（十）基数排序">（十）基数排序</h5><h5 id="（十一）外部排序">（十一）外部排序</h5><h5 id="（十二）排序算法的分析和应用">（十二）排序算法的分析和应用</h5><h3 id="计算机组成原理">计算机组成原理</h3><blockquote><p>参考教材：《计算机组成原理》（唐朔飞）</p></blockquote><h4 id="考查目标-2">[考查目标]</h4><ol><li>掌握单处理器计算机系统中主要部件的工作原理、组成结构以及相互连接方式。</li><li>掌握指令集体系结构的基本知识和基本实现方法，对计算机硬件相关问题进行分析，并能够对相关部件进行设计。</li><li>能够综合运用计算机组成的基本原理和基本方法，对有关计算机硬件系统中的理论和实际问题进行计算、分析，对一些基本部件进行简单设计；并能对高级程序设计语言(如 C语言)中的相关问题进行分析。</li></ol><h4 id="一、计算机系统概述">一、计算机系统概述</h4><h5 id="（一）计算机系统层次结构">（一）计算机系统层次结构</h5><ol><li>计算机系统的基本组成</li><li>计算机硬件的基本结构</li><li>计算机软件和硬件的关系</li><li>计算机系统的工作原理</li></ol><p>“存储程序”工作方式，高级语言程序与机器语言程序之间的转换，程序和指令的执行过程。</p><h5 id="（二）计算机的性能指标">（二）计算机的性能指标</h5><p>吞吐量、响应时间;CPU 时钟周期、主频、CPI、CPU 执行时间;MIPS、 MFLOPS 、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS。</p><h4 id="二、数据的表示和运算">二、数据的表示和运算</h4><h5 id="（一）数制与编码">（一）数制与编码</h5><ol><li>定点计数制及其数据之间的相互转换</li><li>定点数的编码表示</li></ol><h5 id="（二）运算方法和运算电路">（二）运算方法和运算电路</h5><ol><li>基本运算部件</li></ol><p>加法器，算数逻辑单元(ALU)。</p><ol start="2"><li>加/减运算</li></ol><p>补码加/减运算器，标志位的生成。</p><ol start="3"><li>乘/除运算</li></ol><p>乘/除法运算的的基本原理，乘法电路和除法电路的基本结构。</p><h5 id="（三）整数的表示和运算">（三）整数的表示和运算</h5><ol><li>无符号整数的表示和运算</li><li>带符号整数的表示和运算</li></ol><h5 id="（四）浮点数的表示和运算">（四）浮点数的表示和运算</h5><ol><li>浮点数的表示</li></ol><p>IEEE 754标准。</p><ol start="2"><li>浮点数的加/减运算</li></ol><h4 id="三、存储器层次结构">三、存储器层次结构</h4><h5 id="（一）存储器的分类">（一）存储器的分类</h5><h5 id="（二）层次化存储器的基本结构">（二）层次化存储器的基本结构</h5><h5 id="（三）半导体随机存取存储器">（三）半导体随机存取存储器</h5><ol><li>SRAM 存储器</li><li>DRAM 存储器</li><li>Flash 存储器</li></ol><h5 id="（四）主存储器">（四）主存储器</h5><ol><li>DRAM 芯片和内存条</li><li>多模块存储器</li><li>主存和CPU之间的连接</li></ol><h5 id="（五）外部存储器">（五）外部存储器</h5><ol><li>磁盘存储器</li><li>固态硬盘（SSD）</li></ol><h5 id="（六）高速缓存存储器（Cache）">（六）高速缓存存储器（Cache）</h5><ol><li>Cache 的基本原理</li><li>Cache 和主存之间的映射方式</li><li>Cache 中主存块的替换算法</li><li>Cache 写策略</li></ol><h5 id="（七）虚拟存储器">（七）虚拟存储器</h5><ol><li>虚拟存储器的基本概念</li><li>页式虚拟存储器</li></ol><p>基本原理，页表，地址转换，TLB（快表）。</p><ol start="3"><li>段式虚拟存储器的基本原理</li><li>段页式虚拟存储器的基本原理</li></ol><h4 id="四、指令系统">四、指令系统</h4><h5 id="（一）指令系统的基本概念">（一）指令系统的基本概念</h5><h5 id="（二）指令格式">（二）指令格式</h5><h5 id="（三）寻址方式">（三）寻址方式</h5><h5 id="（四）数据的对齐和大-小端存放方式">（四）数据的对齐和大/小端存放方式</h5><h5 id="（五）CISC和RISC的基本概念">（五）CISC和RISC的基本概念</h5><h5 id="（六）高级语言程序与与机器级代码之间的对应">（六）高级语言程序与与机器级代码之间的对应</h5><ol><li>编译器、汇编器和链接器的基本概念</li><li>选择结构语句的机器级表示</li><li>循环结构语句的机器级表示</li><li>过程（函数）调用对应的机器级表示</li></ol><h4 id="五、中央处理器（CPU）">五、中央处理器（CPU）</h4><h5 id="（一）CPU的功能和基本结构">（一）CPU的功能和基本结构</h5><h5 id="（二）指令执行过程">（二）指令执行过程</h5><h5 id="（三）数据通路的功能和基本结构">（三）数据通路的功能和基本结构</h5><h5 id="（四）控制器的功能和工作原理">（四）控制器的功能和工作原理</h5><h5 id="（五）异常和中断机制">（五）异常和中断机制</h5><ol><li>异常和中断的基本概念</li><li>异常和中断的分类</li><li>异常和中断的检测与响应</li></ol><h6 id="（六）指令流水线">（六）指令流水线</h6><ol><li>指令流水线的基本概念</li><li>指令流水线的基本实现</li><li>结构冒险、数据冒险和控制冒险的处理</li><li>超标量和动态流水线的基本概念</li></ol><h5 id="（七）多处理器基本概念">（七）多处理器基本概念</h5><ol><li>SISD、SIMD、MIMD、向量处理器的基本概念</li><li>硬件多线程的基本概念</li><li>多核(multi-core)处理器的基本概念</li><li>共享内存多处理器(SMP)的基本概念</li></ol><h4 id="六、总线和输入-输出系统">六、总线和输入/输出系统</h4><h5 id="（一）总线">（一）总线</h5><ol><li>总线的基本概念</li><li>总线的组成及性能指标</li><li>总线事务和定时</li></ol><h5 id="（二）I-O接口（I-O控制器）">（二）I/O接口（I/O控制器）</h5><ol><li>I/O接口的功能和基本结构</li><li>I/O接口及其编址</li></ol><h5 id="（三）I-O方式">（三）I/O方式</h5><ol><li>程序查询方式</li><li>程序中断方式<br>中断的基本概念，中断响应过程，中断处理过程，多重中断和中断屏蔽的概念。</li><li>DMA方式<br>DMA控制器的组成，DMA传送过程。</li></ol><h3 id="操作系统">操作系统</h3><blockquote><p>参考教材：《计算机操作系统第四版》（汤子瀛版）</p></blockquote><h4 id="考查目标-3">[考查目标]</h4><ol><li>掌握操作系统的基本概念、方法和原理，了解操作系统的结构、功能和服务，理解操作系统所采用的策略算法和机制。</li><li>能够从计算机系统的角度理解并描述应用程序、操作系统内核和计算机硬件协同完成任务的过程。</li><li>能够运用操作系统的原理，分析并解决计算机系统中与操作系统相关的问题。</li></ol><h4 id="一、操作系统基础">一、操作系统基础</h4><h5 id="（一）操作系统的基本概念">（一）操作系统的基本概念</h5><h5 id="（二）操作系统的发展历程">（二）操作系统的发展历程</h5><p><a href="https://blog.cxhap.top/2024/07/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B/">笔记</a></p><h5 id="（三）程序的运行环境">（三）程序的运行环境</h5><ol><li>CPU 运行环境</li></ol><p>内核模式，用户模式。</p><ol start="2"><li>中断和异常的处理</li><li>系统调用</li><li>程序的链接与装入</li><li>程序运行时的内存映像与地址空间</li></ol><h5 id="（四）操作系统结构">（四）操作系统结构</h5><p>分层，模块化，宏内核，微内核，外核。</p><h5 id="（五）操作系统引导">（五）操作系统引导</h5><h5 id="（六）虚拟机">（六）虚拟机</h5><h4 id="二、进程管理">二、进程管理</h4><h5 id="（一）进程与线程">（一）进程与线程</h5><ol><li>进程与线程的基本概念</li><li>进程的状态与转换</li><li>线程的实现</li></ol><p>内核支持的线程，线程库支持的线程。</p><ol start="4"><li><p>进程与线程的组织与控制</p></li><li><p>进程间通信</p></li></ol><p>共享内存，消息传递，管道。</p><h5 id="（二）CPU-调度与上下文切换">（二）CPU 调度与上下文切换</h5><ol><li>调度的基本概念</li><li>调度的目标</li><li>调度的实现</li></ol><p>调度器/调度程序(scheduler)，调度的时机与调度方式（抢占式/非抢占式），闲逛进程，内核级线程与用户级线程调度。</p><ol start="4"><li>典型调度算法</li></ol><p>先来先服务调度算法，短作业（短进程、短线程）优先调度算法，时间片轮转调度算法，优先级调度算法，高响应比优先调度算法，多级队列调度算法，多级反馈队列调度算法。</p><ol start="5"><li>上下文及其切换机制</li></ol><h5 id="（三）同步与互斥">（三）同步与互斥</h5><ol><li>同步与互斥的基本概念</li><li>基本的实现方法</li></ol><p>软件方法，硬件方法。</p><ol start="3"><li>锁</li><li>信号量</li><li>条件变量</li><li>经典同步问题</li></ol><p>生产者-消费者问题，读者-写者问题，哲学家进餐问题等。</p><h5 id="（四）死锁">（四）死锁</h5><ol><li>死锁的基本概念</li><li>死锁预防</li><li>死锁避免</li><li>死锁检测和解除</li></ol><h4 id="三、内存管理">三、内存管理</h4><h5 id="（一）内存管理基础">（一）内存管理基础</h5><ol><li>内存管理的基本概念</li></ol><p>逻辑地址空间与物理地址空间，地址变换，内存共享，内存保护，内存分配与回收。</p><ol start="2"><li>连续分配管理方式</li><li>页式管理</li><li>段式管理</li><li>段页式管理</li></ol><h5 id="（二）虚拟内存管理">（二）虚拟内存管理</h5><ol><li>虚拟内存的基本概念</li><li>请求页式管理</li><li>页框分配</li><li>页面置换算法</li></ol><p>最佳置换算法(OPT);先进先出置换算法(FIFO);最近最少使用置换算法(LRU);时钟置换算法(CLOCK)。</p><ol start="5"><li>内存映射文件(Memory-Mapped Flies)</li><li>虚拟存储器性能的影响因素及改进方法</li></ol><h4 id="四、文件管理">四、文件管理</h4><h5 id="（一）文件">（一）文件</h5><ol><li>文件的基本概念</li><li>文件元数据和索引结点(inode)</li><li>文件的操作</li></ol><p>建立，删除，打开，关闭，读，写。</p><ol start="4"><li>文件的保护</li><li>文件的逻辑结构</li><li>文件的物理结构</li></ol><h5 id="（二）目录">（二）目录</h5><ol><li>目录的基本概念</li><li>树形目录</li><li>目录的操作</li><li>硬链接和软链接</li></ol><h5 id="（三）文件系统">（三）文件系统</h5><ol><li>文件系统的全局结构(layout)</li></ol><p>文件系统在外存中的结构，文件系统在内存中的结构。</p><ol start="2"><li>外存空闲空间管理方法</li><li>虚拟文件系统</li><li>文件系统挂载(mounting)</li></ol><h4 id="五、输入-输出-I-O-管理">五、输入/输出(I/O)管理</h4><h5 id="（一）I-O-管理基础">（一）I/O 管理基础</h5><ol><li>设备</li></ol><p>设备的基本概念，设备的分类，I/O 接口，I/O 端口。</p><ol start="2"><li>I/O 控制方式</li></ol><p>轮询方式，中断方式，DMA 方式。</p><ol start="3"><li>I/O 软件层次结构</li></ol><p>中断处理程序，驱动程序，设备独立软件，用户层I/O软件。</p><ol start="4"><li>输入/输出应用程序接口</li></ol><p>字符设备接口，块设备接口，网络设备接口，阻塞/非阻塞I/O。</p><h5 id="（二）设备独立文件">（二）设备独立文件</h5><ol><li>缓存区管理</li><li>设备分配和回收</li><li>假脱机技术(SPOOLing)</li><li>设备驱动程序接口</li></ol><h5 id="（三）外存管理">（三）外存管理</h5><ol><li>磁盘</li></ol><p>磁盘结构，格式化，分区，磁盘调度方法。</p><ol start="2"><li>固态硬盘</li></ol><p>读写性能特性，磨损均衡。</p><h3 id="计算机网络">计算机网络</h3><blockquote><p>参考教材：《计算机网络第8版》（谢希仁版）</p></blockquote><h4 id="考查目标-4">[考查目标]</h4><ol><li>掌握计算机网络的基本概念、基本原理和基本方法。</li><li>掌握计算机网络的体系结构和典型网络协议，了解典型网络设备的组成和特点，理解典型网络设备的工作原理。</li><li>能够运用计算机网络的基本概念、基本原理和基本方法进行网络系统的分析、设计和应用。</li></ol><h4 id="一、计算机网络概述">一、计算机网络概述</h4><h5 id="（一）计算机网络基本概念">（一）计算机网络基本概念</h5><ol><li>计算机网络的定义、组成与功能</li><li>计算机网络的分类</li><li>计算机网络的主要性能指标</li></ol><h5 id="（二）计算机网络体系结构">（二）计算机网络体系结构</h5><ol><li>计算机网络分层结构</li><li>计算机网络协议、接口、服务等概念</li><li>ISO / OSI参考模型和TCP / IP模型</li></ol><h4 id="二、物理层">二、物理层</h4><h5 id="（一）通信基础">（一）通信基础</h5><ol><li>信道、信号、带宽、码元、波特、速率、信源与信宿等基本概念</li><li>奈奎斯特定理与香农定理</li><li>编码与调制</li><li>电路交换、报文交换与分组交换</li><li>数据报与虚电报</li></ol><h5 id="（二）传输介质">（二）传输介质</h5><ol><li>双绞线、同轴电缆、光纤与无线传输介质</li><li>物理层接口的特性</li></ol><h5 id="（三）物理层设备">（三）物理层设备</h5><ol><li>中继器</li><li>集线器</li></ol><h4 id="三、数据链路层">三、数据链路层</h4><h5 id="（一）数据链路层的功能">（一）数据链路层的功能</h5><h5 id="（二）组帧">（二）组帧</h5><h5 id="（三）差错控制">（三）差错控制</h5><ol><li>检错编码</li><li>纠错编码</li></ol><h5 id="（四）流量控制与可靠传输机制">（四）流量控制与可靠传输机制</h5><ol><li>流量控制、可靠传输与滑动窗口机制</li><li>停止 - 等待协议</li><li>后退N帧协议( GBN )</li><li>选择重传协议( SR )</li></ol><h5 id="（五）介质访问控制">（五）介质访问控制</h5><ol><li>信道划分</li></ol><p>频分多路复用、时分多路复用、波分多路复用、码分多路复用的概念和基本原理。</p><ol start="2"><li>随机访问</li></ol><p>ALOHA 协议;CSMA 协议;CSMA/CD 协议;CSMA/CA 协议。</p><ol start="3"><li>轮询访问</li></ol><p>令牌传递协议。</p><h5 id="（六）局域网">（六）局域网</h5><ol><li>局域网的基本概念与体系结构</li><li>以太网与IEEE 802.3</li><li>IEEE 802.11无线局域网</li><li>VLAN 基本概念与基本原理</li></ol><h5 id="（七）广域网">（七）广域网</h5><ol><li>广域网的基本概念</li><li>PPP 协议</li></ol><h5 id="（八）数据链路层设备">（八）数据链路层设备</h5><p>以太网交换机及其工作原理</p><h4 id="四、网络层">四、网络层</h4><h5 id="（一）网络层的功能">（一）网络层的功能</h5><ol><li>异构网络互连</li><li>路由和转发</li><li>SDN 基本概念</li><li>阻塞控制</li></ol><h5 id="（二）路由算法">（二）路由算法</h5><ol><li>静态路由与动态路由</li><li>距离-向量路由算法</li><li>链路状态路由算法</li><li>层次路由</li></ol><h5 id="（三）IPv4">（三）IPv4</h5><ol><li>IPv4 分组</li><li>IPv4 地址与 NAT</li><li>子网划分、路由聚集、子网掩码与 CIDR</li><li>ARP 协议、DHCP 协议与 ICMP 协议</li></ol><h5 id="（四）IPv6">（四）IPv6</h5><ol><li>Ipv6 的主要特点</li><li>IPv6 地址</li></ol><h5 id="（五）路由协议">（五）路由协议</h5><ol><li>自治系统</li><li>域内路由与域间路由</li><li>RIP 路由协议</li><li>OSPF 路由协议</li><li>BGP 路由协议</li></ol><h5 id="（六）IP组播">（六）IP组播</h5><ol><li>组播的概念</li><li>IP 组播地址</li></ol><h5 id="（七）移动-IP">（七）移动 IP</h5><ol><li>移动 IP 的概念</li><li>移动 IP 的通信过程</li></ol><h5 id="（八）网络层设备">（八）网络层设备</h5><ol><li>路由器的组成和功能</li><li>路由表与分组转发</li></ol><h4 id="五、传输层">五、传输层</h4><h5 id="（一）传输层提供的服务">（一）传输层提供的服务</h5><ol><li>传输层的功能</li><li>传输层寻址与端口</li><li>无连接服务与面向连接服务</li></ol><h5 id="（二）UDP-协议">（二）UDP 协议</h5><ol><li>UDP 数据报</li><li>UDP 校验</li></ol><h5 id="（三）TCP-协议">（三）TCP 协议</h5><ol><li>TCP 段</li><li>TCP 连接管理</li><li>TCP 可靠传输</li><li>TCP 流量控制</li><li>TCP 拥塞控制</li></ol><h4 id="六、应用层">六、应用层</h4><h5 id="（一）网络应用模型">（一）网络应用模型</h5><ol><li>客户/服务端(C/S)模型</li><li>对等(P2P)模型</li></ol><h5 id="（二）DNS-系统">（二）DNS 系统</h5><ol><li>层次域名空间</li><li>域名服务器</li><li>域名解析过程</li></ol><h5 id="（三）FTP">（三）FTP</h5><ol><li>FTP 协议的工作原理</li><li>控制连接与数据连接</li></ol><h5 id="（四）电子邮件">（四）电子邮件</h5><ol><li>电子邮件系统的组成结构</li><li>电子邮件的结构与 MIME</li><li>SMTP 协议与POP3 协议</li></ol><h5 id="（五）WWW">（五）WWW</h5><ol><li>WWW 的概念与组成结构</li><li>HTTP 协议</li></ol>]]></content>
    
    
    <categories>
      
      <category>0812计算机考研408</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机科学与技术</tag>
      
      <tag>812</tag>
      
      <tag>考试大纲</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Github Pages与Actions搭建个人Hexo博客</title>
    <link href="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1>使用Github Pages与Actions搭建个人Hexo博客</h1><h2 id="引言">引言</h2><p>作为一名计算机专业的学生，拥有一个自己的博客网站无疑是一件非常酷的事情。然而，搭建一个网站不仅需要完成大量的工作，还需要支付一定的费用来购买或租用服务器并进行维护。那么，有没有一种更简单的方法来搭建博客呢？答案是肯定的。正如标题所示，我们可以利用 GitHub Pages 来搭建一个全前端的网站，轻松实现我们的博客需求。</p><h2 id="Hexo-介绍">Hexo 介绍</h2><p>Hexo 是一个快速、简洁且高效的静态博客框架。它使用 Markdown 或其他渲染引擎生成静态文件，并且支持丰富的插件和主题，方便用户自定义博客的外观和功能。</p><blockquote><p>以下内容部分由ChatGPT生成。</p></blockquote><h3 id="为什么选择-Hexo？">为什么选择 Hexo？</h3><ol><li><strong>性能优越</strong>：Hexo 生成的静态页面加载速度非常快，这得益于它生成的文件不需要服务器端的动态处理。</li><li><strong>易于使用</strong>：Hexo 提供了简单易用的命令行工具，方便用户快速创建、发布和管理博客内容。</li><li><strong>灵活的插件系统</strong>：Hexo 拥有丰富的插件库，用户可以根据需要安装插件来扩展博客的功能，如评论系统、搜索功能等。</li><li><strong>强大的主题支持</strong>：Hexo 社区有大量精美的主题可供选择，用户可以轻松更换博客的外观，使其更具个性化。</li><li><strong>活跃的社区</strong>：Hexo 拥有一个活跃的社区，用户可以通过社区获得帮助，分享经验和资源。</li></ol><h3 id="Hexo-的基本架构">Hexo 的基本架构</h3><p>Hexo 的架构主要包括以下几个部分：</p><ol><li><strong>Hexo 核心</strong>：负责博客的基本功能，如文章管理、静态文件生成等。</li><li><strong>Hexo 插件</strong>：用于扩展 Hexo 功能的模块，例如 SEO 优化、RSS 生成等。</li><li><strong>Hexo 主题</strong>：决定博客外观和布局的模板文件，用户可以根据喜好选择和更换主题。</li><li><strong>Hexo 渲染引擎</strong>：负责将 Markdown 等格式的源文件渲染为 HTML 静态文件。</li></ol><h3 id="post和page的区别">post和page的区别</h3><p>在 Hexo 中，<code>page</code>（页面）和 <code>post</code>（文章）是两种常用的不同类型的内容：</p><ol><li><p><strong>Post（文章）</strong>：</p><ul><li><strong>定义</strong>：Post 是指博客中的文章或日志，通常是按时间顺序排列的内容，例如博客文章、新闻稿等。</li><li><strong>存放位置</strong>：通常存放在 <code>source/_posts</code> 目录下（可以在配置文件中指定其他目录）。</li><li><strong>命名规则</strong>：通常以 Markdown 或其他支持的格式书写，并以日期和标题命名，例如 <code>2024-07-10-my-first-post.md</code>。</li><li><strong>生成</strong>：生成时会被自动排序和归档，可以通过配置自动生成目录、标签、分类等信息。</li></ul></li><li><p><strong>Page（页面）</strong>：</p><ul><li><strong>定义</strong>：Page 是指博客中的静态页面，通常不按时间顺序排列，而是作为独立的页面存在，如关于页面、联系页面等。</li><li><strong>存放位置</strong>：通常存放在 <code>source</code> 目录下或 <code>source</code> 下的其他子目录中，如 <code>source/about/index.md</code>。</li><li><strong>命名规则</strong>：可以是 Markdown 格式，也可以是其他支持的格式，文件名通常就是页面的路径。</li><li><strong>生成</strong>：生成时作为站点的固定页面存在，可以通过导航链接访问。</li></ul></li></ol><h3 id="如何开始使用-Hexo？">如何开始使用 Hexo？</h3><blockquote><p>跳转到<a href="#%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2Hexo%E5%8D%9A%E5%AE%A2">本地部署Hexo博客</a>？</p></blockquote><ol><li><strong>安装 Node.js 和 Git</strong>：Hexo 依赖于 Node.js 和 Git，首先需要在系统中安装这两个工具。</li><li><strong>安装 Hexo</strong>：使用 npm（Node.js 包管理工具）安装 Hexo：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure></li><li><strong>初始化博客</strong>：在目标目录下初始化一个新的 Hexo 博客：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init my-blog<br><span class="hljs-built_in">cd</span> my-blog<br>npm install<br></code></pre></td></tr></table></figure></li><li><strong>创建文章</strong>：使用 Hexo 提供的命令创建新文章：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;My First Post&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>生成和预览</strong>：生成静态文件并在本地服务器中预览博客：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure>在浏览器中访问 <code>http://localhost:4000</code> 查看博客效果。</li></ol><h3 id="部署到-GitHub-Pages">部署到 GitHub Pages</h3><p>Hexo 提供了简便的部署命令，可以将生成的静态文件直接部署到 GitHub Pages：</p><ol><li><strong>配置部署信息</strong>：在博客根目录的 <code>_config.yml</code> 文件中配置 GitHub Pages 的仓库信息：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/username/username.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li><li><strong>安装部署插件</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure></li><li><strong>执行部署命令</strong>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure></li></ol><p>通过以上步骤，你就可以轻松地将 Hexo 博客部署到 GitHub Pages 上，拥有一个免费的个人博客网站。</p><h2 id="本地部署Hexo博客">本地部署Hexo博客</h2><p>基本步骤可参考GPT生成部分<a href="#%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-Hexo%EF%BC%9F">如何开始使用 Hexo？</a>。node.js与git的安装与配置可根据不同的操作系统在网上查找安装方法，下面将对基础的安装步骤进行补充。</p><h3 id="切换主题">切换主题</h3><p>Hexo提供了许多免费的主题可供直接使用，用户可以个性化选择主题以达到自己想要的结果，可以去<a href="https://hexo.io/themes/">Hexo官方主题仓库</a>挑选自己喜欢的主题。但需要注意的是，每款主题的配置文件可能各不相同，我使用的是<strong>Fluid</strong>主题，下面的配置以该主题为准，大家可自行根据配置文件注释进行配置。</p><h4 id="下载主题">下载主题</h4><p>前往Fluid主题官方<a href="https://github.com/fluid-dev/hexo-theme-fluid">Github仓库</a>下载zip压缩包即可，直接解压至my_blog/theme目录，并将<strong>hexo-theme-fluid</strong>更名为<strong>fluid</strong>。</p><blockquote><p>顺便在这里解释一下Hexo项目的目录结构，<code>node_modules</code>是nodejs自动生成的模块目录，<code>public</code>是编译出的静态页面地址，<code>scaffolds</code>是自动新建的页面或博客模板文件，<code>source</code>中存放页面和post的源文件（.md形式）以及部分图片，其中页面单独成一个目录，博客文件则存放在<code>_posts</code>中，关于post和页面的区别请见<a href="#post%E5%92%8Cpage%E7%9A%84%E5%8C%BA%E5%88%AB">post和page的区别</a>,<code>theme</code>中存放主题。</p></blockquote><h4 id="应用主题">应用主题</h4><p>寻找my_blog根目录下配置文件**_config.yml**，找到<strong>theme</strong>这一行，修改为<code>theme: fluid</code>，别忘了:后面有一个空格。修改完配置文件后自己去看看效果吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br>hexo server<br></code></pre></td></tr></table></figure><h3 id="更多配置内容">更多配置内容</h3><p>为了节约篇幅和更直观形象，下面将用表格呈现一些有用的配置内容。需要注意的是，一个Hexo项目有一个自己的配置文件<code>_config.yml</code>，此外每个主题还有一个自己的配置文件<code>themes/fluid/_config.yml</code>。</p><p>表1：_config.yml</p><table><thead><tr><th>键(Key)</th><th>值(Val)</th><th>描述(Description)</th></tr></thead><tbody><tr><td>title</td><td>Your Blog Title</td><td>浏览器tab页名称</td></tr><tr><td>subtitle</td><td>Your Subtitle</td><td>title的副标题</td></tr><tr><td>description</td><td>Your description</td><td>网站的描述</td></tr><tr><td>author</td><td>Your Name</td><td>文章作者名</td></tr><tr><td>language</td><td>“zh-CN”</td><td>网站语言</td></tr><tr><td>timezone</td><td>‘’</td><td>时区设置，可置空</td></tr><tr><td>url</td><td>Your Blog url</td><td>可设置成Github Page的地址</td></tr><tr><td>new_post_name</td><td>:year-:month-:day-:title.md</td><td>post的模板标题</td></tr><tr><td>post_asset_folder</td><td>true</td><td>为每个post自动建立资源文件夹</td></tr><tr><td>theme</td><td>fluid</td><td>所使用的主题名称</td></tr></tbody></table><p>表2：themes/fluid/_config.yml</p><table><thead><tr><th>键(Key)</th><th>值(Val)</th><th>描述(Description)</th></tr></thead><tbody><tr><td>favicon</td><td>/img/fluid.png</td><td>浏览器标签的图标</td></tr><tr><td>apple_touch_icon</td><td>/img/fluid.png</td><td>苹果设备的图标</td></tr><tr><td>blog_title</td><td>Your blog_title</td><td>导航栏左侧的标题</td></tr><tr><td>menu</td><td>…</td><td>导航栏菜单，可自行添加页面</td></tr><tr><td>index/slogan/text</td><td>…</td><td>显示在主页的文字</td></tr><tr><td>about/*</td><td>…</td><td>自定义关于页面的个人信息</td></tr></tbody></table><p>以上只是我建议修改的配置内容，如查找进阶内容请参考<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">Hexo Fluid 用户手册</a>与<a href="https://hexo.io/zh-cn/docs/">Hexo手册</a>自行研究。</p><h3 id="增加阅读量统计">增加阅读量统计</h3><p>参考文章<a href="http://minghuijia.cn/2022/03/14/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F/">Hexo-fluid主题设置统计博客阅读量</a></p><h3 id="增加评论功能">增加评论功能</h3><p>参考文章<a href="http://minghuijia.cn/2022/03/14/Hexo-fluid%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E7%BB%9F%E8%AE%A1%E5%8D%9A%E5%AE%A2%E9%98%85%E8%AF%BB%E9%87%8F/">Hexo-fluid主题设置统计博客阅读量</a></p><h3 id="显示数学公式">显示数学公式</h3><blockquote><p>参考官方配置指南<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F">latex-数学公式</a>，基本配置和官方类似，但需要注意安装pandoc工具（使用mathjax），否则会报错。</p></blockquote><h4 id="1-设置主题配置">1. 设置主题配置</h4><p>编辑主题配置文件themes/fluid/_config.yml</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br><span class="hljs-attr">math:</span><br>   <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>   <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br>   <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure><p><code>specific</code>: 建议开启。当为 true 时，只有在文章 front-matter (opens new window)里指定 <code>math: true</code> 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度。</p><p><code>engine</code>: 公式引擎，目前支持 <code>mathjax</code> 或 <code>katex</code>。</p><h4 id="2-更换-Markdown-渲染器">2. 更换 Markdown 渲染器</h4><p>由于 Hexo 默认的 Markdown 渲染器不支持复杂公式，所以需要更换渲染器（mathjax 可选择性更换）。</p><p>然后根据上方配置不同的 <code>engine</code>，推荐更换如下渲染器：</p><ol><li>mathjax</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure><p>并且还需安装pandoc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install pandoc -y<br></code></pre></td></tr></table></figure><ol start="2"><li>katex</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br>npm install hexo-renderer-markdown-it --save<br>npm install @traptitech/markdown-it-katex --save<br></code></pre></td></tr></table></figure><p>然后在站点配置中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">markdown:</span><br>  <span class="hljs-attr">plugins:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;@traptitech/markdown-it-katex&quot;</span><br></code></pre></td></tr></table></figure><h4 id="清理环境">清理环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><h2 id="添加博客页面与文章">添加博客页面与文章</h2><h3 id="添加About页面">添加About页面</h3><p>使用<code>hexo new page about</code>即可新建一个about页面，页面默认存放在<strong>source</strong>文件夹中，一个页面就是一个文件夹。</p><h3 id="从模板新建文章">从模板新建文章</h3><p>同理，使用<code>hexo new post newpost</code>即可新建一篇文章，文章默认存放在<strong>source/_posts</strong>文件夹中，所有的文章都存储在**_posts**文件夹中，但可在文章同级目录建立同名文件夹以存放图片等资源文件，如下图。</p><img src="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/1.png" class="" title="post目录结构"><h2 id="配置Github-Action自动发布到Github-Page">配置Github Action自动发布到Github Page</h2><p>经过上面的配置操作，相信你已经成功在本地运行起来了自己的博客，但仅仅运行在本地肯定不够，我们需要将博客推送到github page中，通过username.github.io或是通过自己的域名进行访问。</p><h3 id="原理">原理</h3><p>github page支持的是静态页面，而hexo编译后生成的<code>public</code>文件夹内存放的便是静态页面，因此我们只需要将<code>public</code>文件夹内的内容推送至个人github page仓库即可。</p><h3 id="准备工作">准备工作</h3><p>首先你需要注册一个自己的github账号，并且进行了一系列的安全配置工作。</p><h4 id="创建Github仓库">创建Github仓库</h4><p>我们需要创建两个仓库来完成操作，其中一个仓库名随意，我使用的名称是hexo-blog，另一个仓库名必须以<code>yourusername.github.io</code>为名字，在创建时会提示你这个仓库是特殊仓库，如下图（因为我预先创建过了，显示仓库已存在）。其中<code>yourusername.github.io</code>仓库必须设为<strong>public</strong>。</p><img src="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/2.png" class="" title="创建仓库"><h4 id="配置git">配置git</h4><p>我们需要使用git工具来将本地代码推送至github仓库，git工具在第一次使用前必须进行相关配置。参考<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C-Git-%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE">官方文档</a>。</p><h4 id="同步代码">同步代码</h4><p>为了便于操作，我使用vscode来完成git推送工作，我们首先使用git工具克隆一份空仓库，仓库地址可从Github获取，如下图。</p><img src="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/3.png" class="" title="仓库URL"><p>在终端使用命令<code>git clone your-repository-url</code>克隆到本地，并且将之前创建的hexo项目复制到文件夹下（要将my_blog下的所有文件以及文件夹复制到hexo-blog文件夹下，而不是复制整个my_blog文件夹），接着使用vscode打开文件夹，保持目录结构如下图。</p><img src="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/4.png" class="" title="目录结构"><p>然后试试vscode的源代码管理功能吧。这里第一次点击提交是提交更改，第二次则是同步到仓库，第一次提交时必须填写消息。</p><img src="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/5.png" class="" title="源代码管理"><p>同步完成后，去Github仓库看下是否同步成功吧。</p><h4 id="拷贝主题配置文件">拷贝主题配置文件</h4><p>由于我的github action脚本会自动拉取最新版本主题，因此主题的配置文件必须保存在其他地方，在部署时复制进去即可，因此我们提前将主题配置文件<code>themes/fluid/_config.yml</code>复制到<code>_config_theme.yml</code>。</p><h4 id="配置github-action">配置github action</h4><h5 id="配置SSH密钥对">配置SSH密钥对</h5><p>使用命令<code>ssh-keygen -f github-deploy-key</code>在当前工作目录下可生成文件<code>github-deploy-key</code>和<code>github-deploy-key.pub</code>。</p><p>复制 github-deploy-key 文件内容，在 hexo-blog 仓库 <code>Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret</code> 页面上添加。</p><ol><li>在 Name 输入框填写 HEXO_DEPLOY_PRI。</li><li>在 Value 输入框填写 github-deploy-key 文件内容。</li></ol><p>复制 github-deploy-key.pub 文件内容，在 <a href="http://your.github.io">your.github.io</a> 仓库 Settings -&gt; Deploy keys -&gt; Add deploy key 页面上添加。</p><ol><li>在 Title 输入框填写 HEXO_DEPLOY_PUB。</li><li>在 Key 输入框填写 github-deploy-key.pub 文件内容。</li><li>勾选 Allow write access 选项。</li></ol><h5 id="配置GH-Token">配置GH_Token</h5><p>使用hexo-deployer-git工具部署时需要github personal access token，而且这个token是不能写在配置文件中的，因此只能写在仓库环境变量中，在action部署时自动获取。点击你的GitHub头像 -&gt; 设置 -&gt; 开发者设置 -&gt; Personal access tokens -&gt; Generate new token来获取这个token,设置权限时只需要设置有关repository的读写权限即可。<br>复制 personal access token 内容，在 hexo-blog 仓库 <code>Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret</code> 页面上添加。</p><ol><li>在 Name 输入框填写 GH_TOKEN。</li><li>在 Value 输入框填写 personal access token 内容。</li></ol><h5 id="添加github-action">添加github action</h5><p>新建文件<code>.github/workflows/deploy.yml</code>，将下面的模板内容粘贴进去，然后根据自己的需要进行修改，需要修改的地方已标出。</p>   <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">CI</span><br><br><span class="hljs-attr">on:</span><br><span class="hljs-attr">push:</span><br>   <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-attr">env:</span><br><span class="hljs-attr">GIT_USER:</span> <span class="hljs-string">DingWH03</span> <span class="hljs-comment"># 这里更改为自己的Github用户名</span><br><span class="hljs-attr">GIT_EMAIL:</span> <span class="hljs-number">2521248869</span><span class="hljs-string">@qq.com</span> <span class="hljs-comment"># 这里更改为自己的Github绑定的邮箱</span><br><span class="hljs-attr">THEME_REPO:</span> <span class="hljs-string">fluid-dev/hexo-theme-fluid</span> <span class="hljs-comment"># 这里更改为你使用的主题的git仓库，省略github.com</span><br><span class="hljs-attr">THEME_BRANCH:</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 这里更改为你使用的主题的git分支</span><br><span class="hljs-attr">DEPLOY_REPO:</span> <span class="hljs-string">DingWH03/dingwh03.github.io</span> <span class="hljs-comment"># 这里更改为你自己的仓库地址，省略github.com</span><br><span class="hljs-attr">DEPLOY_BRANCH:</span> <span class="hljs-string">main</span> <span class="hljs-comment"># 这里更改为你自己的仓库分支，一般都是main</span><br><br><span class="hljs-attr">jobs:</span><br><span class="hljs-attr">build:</span><br>   <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">on</span> <span class="hljs-string">node</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">and</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.os</span> <span class="hljs-string">&#125;&#125;</span><br>   <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>   <span class="hljs-attr">strategy:</span><br>      <span class="hljs-attr">matrix:</span><br>      <span class="hljs-attr">os:</span> [<span class="hljs-string">ubuntu-latest</span>]<br>      <span class="hljs-attr">node_version:</span> [<span class="hljs-number">16.</span><span class="hljs-string">x</span>]<br><br>   <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">theme</span> <span class="hljs-string">repo</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>      <span class="hljs-attr">with:</span><br>         <span class="hljs-attr">repository:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.THEME_REPO</span> <span class="hljs-string">&#125;&#125;</span><br>         <span class="hljs-attr">ref:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.THEME_BRANCH</span> <span class="hljs-string">&#125;&#125;</span><br>         <span class="hljs-attr">path:</span> <span class="hljs-string">themes/fluid</span> <span class="hljs-comment"># 这里更换成你的主题所在路径</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">deploy</span> <span class="hljs-string">repo</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v4</span><br>      <span class="hljs-attr">with:</span><br>         <span class="hljs-attr">repository:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.DEPLOY_REPO</span> <span class="hljs-string">&#125;&#125;</span><br>         <span class="hljs-attr">ref:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">env.DEPLOY_BRANCH</span> <span class="hljs-string">&#125;&#125;</span><br>         <span class="hljs-attr">path:</span> <span class="hljs-string">.deploy_git</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">Node.js</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v4</span><br>      <span class="hljs-attr">with:</span><br>         <span class="hljs-attr">node-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.node_version</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configuration</span> <span class="hljs-string">environment</span><br>      <span class="hljs-attr">env:</span><br>         <span class="hljs-attr">HEXO_DEPLOY_PRI:</span> <span class="hljs-string">$&#123;&#123;secrets.HEXO_DEPLOY_PRI&#125;&#125;</span><br>         <span class="hljs-attr">GH_TOKEN:</span> <span class="hljs-string">$&#123;&#123;secrets.GH_TOKEN&#125;&#125;</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">         sudo apt-get install pandoc -y # pandoc是为了启用数学公式渲染</span><br><span class="hljs-string">         sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span><br><span class="hljs-string">         mkdir -p ~/.ssh/</span><br><span class="hljs-string">         echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">         chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">         ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">         git config --global user.name $GIT_USER</span><br><span class="hljs-string">         git config --global user.email $GIT_EMAIL</span><br><span class="hljs-string">         cp _config_theme.yml themes/fluid/_config.yml # 拷贝主题的配置文件</span><br><span class="hljs-string">         sed -i &quot;s|token:.*|token: $&#123;GH_TOKEN&#125;|&quot; _config.yml </span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">         npm install</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">hexo</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">         npm run deploy</span><br><span class="hljs-string"></span>      <br>      <span class="hljs-comment">#- name: Add CNAME file # 这部分用来为github page添加自己的域名，后面会讲</span><br>      <span class="hljs-comment">#run: |</span><br>      <span class="hljs-comment">#   echo &quot;blog.cxhap.top&quot; &gt; .deploy_git/CNAME # 改成你的域名地址</span><br>      <span class="hljs-comment">#   cd .deploy_git</span><br>      <span class="hljs-comment">#   git config user.name &quot;$GIT_USER&quot;</span><br>      <span class="hljs-comment">#   git config user.email &quot;$GIT_EMAIL&quot;</span><br>      <span class="hljs-comment">#   git add CNAME</span><br>      <span class="hljs-comment">#   git commit -m &quot;Add CNAME file for custom domain&quot;</span><br>      <span class="hljs-comment">#   git remote set-url origin git@github.com:DingWH03/dingwh03.github.io.git</span><br>      <span class="hljs-comment">#   git push origin HEAD:main</span><br></code></pre></td></tr></table></figure><h5 id="为github-page添加自己的域名">为github page添加自己的域名</h5><blockquote><p>最新更正，现在有更简单的方法，编写一个文件名为CNAME存放在<code>source/CNAME</code>，文件内容为你的域名，在部署时会直接放置到github page根目录，这样做或避免相邻两次重复部署github page。<br>参考<a href="https://github.com/hexojs/hexo-deployer-git/issues/87">hexo-deployer-git_issues#87</a>。</p></blockquote><p>步骤和原理都很简单，在你的域名DNS解析中添加一条CNAME解析指向你的github.io地址，然后在github.io仓库中添加一个CNAME文件，里面内容即是你的域名，在上面的脚本中已经体现出来了。</p><img src="/2024/07/06/2024-7-6-%E4%BD%BF%E7%94%A8Github-Pages%E4%B8%8EActions%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAHexo%E5%8D%9A%E5%AE%A2/6.png" class="" title="cloudfare"><p>同步一下仓库吧，不出意外的话Github action会自动执行，并且上传到github.io中。如遇到问题欢迎与我联系。</p>]]></content>
    
    
    <categories>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github Pages</tag>
      
      <tag>Github Actions</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenWrt简易校园网自动认证+双WAN配置</title>
    <link href="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1>OpenWrt校园网自动认证+双WAN配置</h1><p>最近换了新宿舍，旧的tp-link路由器搬东西的时候坏了，于是去闲鱼上50元淘了个刷好了openwrt的极路由4，路由器是有点老，但是好在人家便宜，刷上openwrt玩法也多，经过在网上查阅资料，成功配置好了双wan接入，配置好负载均衡后可叠加网速（其实相对于校园网来说电信宽带50M带宽实属有点捉襟见肘，但是人家有公网IPV4啊），配合HFUT校园网自动认证脚本可实现路由器端自动登录。</p><h2 id="线路连接">线路连接</h2><p>原生WAN口连接电信宽带，拨号上网，LAN1口配置成WAN2，直接接入校园网，或者接入已经接入校园网的并配置成关闭DHCP的路由器</p><blockquote><p>路由器关闭DHCP可视为AP模式，相当于交换机的功能，每个连接的用户可视为一个单独的用户，每个人都需要进行认证，每个人独立带宽。否则所有连接到路由器的人用同一个校园网账号上网。</p></blockquote><h2 id="宽带拨号上网">宽带拨号上网</h2><p>登录openwrt，选择<strong>网络-&gt;接口-&gt;WAN</strong>，找到WAN点击编辑，将协议修改为PPPOE，并在下面设置好宽带账号密码即可。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/1pppoe.png" class="" title="pppoe-wan"><blockquote><p>若账号密码正确但始终无法拨号成功，检查线路连接正常后，拨打10000号人工客服解绑一下端口吧，换设备容易出现这种情况。<br>配置完成后记得点击<strong>保存并应用</strong>，这样才会生效。</p></blockquote><h2 id="设置LAN1为WAN2">设置LAN1为WAN2</h2><p>首先在刚才的<strong>网络-&gt;接口</strong>页面，选择设备标签页，将LAN1先取消配置，然后从网桥设备中移除。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/3.png" class="" title="从网桥中移除lan1"><p>然后选择添加设备，再将LAN1添加为<strong>网络设备</strong>，配置项保持默认即可保持默认即可。</p><blockquote><p>也许不用删除LAN1再添加，谁知道呢，反正我删除再添加没遇到问题。<br>再次来到<strong>接口</strong>页面，点击左下角添加新接口，名称为WAN2，协议选择DHCP客户端（自动获取ip地址），设备选择LAN1，然后为WAN2配置防火墙区域，放在外网WAN一组即可。</p></blockquote><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/4.png" class="" title="配置防火墙区域"><h2 id="为WAN与WAN2设置网关跃点">为WAN与WAN2设置网关跃点</h2><p>跃点数决定了两个WAN的优先级，数字越小优先级越高，要配置下面的负载均衡一定要为WAN和WAN2设置成不同的跃点数，在<strong>网络-&gt;接口-&gt;WAN-&gt;编辑-&gt;高级设置-&gt;使用网关跃点进行设置</strong>，如下图。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/5.png" class="" title="配置网关跃点"><h2 id="配置负载均衡">配置负载均衡</h2><p>负载均衡的存在是为了让网络同时使用两条WAN接口，将WAN与WAN2配置成balanced可以实现网速叠加。</p><h3 id="配置接口">配置接口</h3><p>在<strong>网络-&gt;负载均衡-&gt;接口</strong>标签页中，若已有其他接口添加可以选择删除，然后为WAN、WAN2添加进接口中，只需要添加跟踪主机或ip地址即可，<a href="http://xn--www-st5fh1bx7kgu8ahx6b.baidu.com">我选择的是www.baidu.com</a>，用于判断网络连接是否正常。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/6.png" class="" title="MWAN接口"><p>然后为WAN2校园网接口添加<strong>刷新连接跟踪表</strong>，作用是后面需要实现的校园网自动登录。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/7.png" class="" title="刷新连接跟踪表"><p>配置完成后如下图，显示出跃点数才算成功。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/8.png" class="" title="接口配置成功"><h3 id="配置成员">配置成员</h3><p>为两个接口配置成员即可，跃点数决定负载均衡优先级，一般相同即可，权重可配置成两条接入WAN带宽之比。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/9.png" class="" title="成员配置"><h3 id="配置策略">配置策略</h3><p>这里建议添加两个策略，一个是balanced均衡，另一个是wan2_only，及仅校园网。balanced选择两个成员，wan2_only选择wan2即可。</p><blockquote><p>在某些情况下，某些银行app以及部分使用https协议的应用，在双ip负载均衡条件下可能会报ip切换速度过快的警告，当然切换过快，毕竟一个应用数据通过两条线与服务器连接。</p></blockquote><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/10.png" class="" title="策略配置"><h3 id="配置规则">配置规则</h3><p>为了配合前面我们添加的策略，我们添加两条规则，分别是Default_role和https，像下图这样配置即可。</p><img src="/2024/07/04/2024-7-4-OpenWrt%E6%A0%A1%E5%9B%AD%E7%BD%91%E8%87%AA%E5%8A%A8%E8%AE%A4%E8%AF%81-%E5%8F%8CWAN%E9%85%8D%E7%BD%AE/11.png" class="" title="规则配置"><p>点击保存并应用后，至此算是配置成功了，但是当前还是不能访问网络，因为校园网登录还没实现。</p><h2 id="校园网自动登录">校园网自动登录</h2><p>这里我提供合肥工业大学合肥校区校园网自动登录脚本，其他学校的可以优先查找Github仓库，若找不到，技术强的大佬可以通过抓包的方式自行摸索。自动登录脚本参考自<a href="https://github.com/HowardZorn/HFUT-DrCOM">合肥工业大学校园网自动登陆指南</a>，我为了做成自动化脚本稍微进行了一些改动。</p><pre><code class="hljs">#!/bin/bashusername=&quot;2022xxxxxx&quot;password=&quot;xxxxxx&quot;echo 'Checking IP address and network connectivity...'# Get the IP address of the current machineip_address=$(ip -4 addr show lan1 | awk '/inet / &#123;print $2&#125;')# Function to test network connectivitycheck_network() &#123;    local url=&quot;http://detectportal.firefox.com/success.txt&quot;    local expected=&quot;success&quot;    # Use curl to fetch the content of the URL and store it in a variable    local content=$(curl --ipv4 --silent --max-time 5 --interface lan1 &quot;$url&quot;)    local result=$?    if [ $result -eq 0 ] &amp;&amp; [ &quot;$content&quot; = &quot;$expected&quot; ]; then#         echo &quot;Network connectivity test successful.&quot;        return 0  # Success    else#         echo &quot;Failed to establish network connectivity or content does not match.&quot;        return 1  # Failure    fi&#125;# Check if the IP address starts with &quot;170&quot; and if the network test times outif [[ $ip_address == 172.* ]]; then    echo 'IP address starts with 172.'    if ! check_network; then        echo 'Network test failed. Executing login script...'        # visit 172.16.200.11/12/13 to obtain the session giver URL.        # http://210.45.240.245/switch.php?xxxxx will give you the correct session id.        url=$(curl 172.16.200.13 --silent --interface lan1 | sed -n &quot;s/.*'\(.*\)'.*/\1/p&quot;)        # get PHP session        curl $url --cookie ./cookies --cookie-jar ./cookies --output /dev/null --silent --interface lan1        # login, phpsessid is a critical parameter.        curl http://210.45.240.245/post.php --cookie ./cookies --cookie-jar ./cookies --data-urlencode 'username='$username --data-urlencode 'password='$password --data-urlencode '0MKKey=%B5%C7+%C2%BC' --silent --interface lan1        # test        curl --ipv4 --silent --interface lan1 http://detectportal.firefox.com/success.txt        echo 'Login script executed.'    else        echo 'Network test succeeded. No need to execute login script.'    fielse    echo 'IP address does not start with 172. Skipping login script.'fi</code></pre><p>将该脚本保存至/root/auto-login.sh，修改成正确的账号密码，授予可执行权限<code>chmod +x ./auto-login.sh</code>。<br>再次打开openwrt管理网页，找到<strong>网络-&gt;负载均衡-&gt;通知</strong>，将下面两行代码粘贴进文件最后两行，当WAN2状态改变时会自动执行这个脚本，登录到校园网。<br>bash /root/auto-login.sh &gt; /root/auto-login.log<br>date &gt; /root/flag</p><blockquote><p>还记得配置负载均衡的配置接口部分的<strong>刷新连接跟踪表</strong>吗，那玩意就是用来触发这个脚本的。</p></blockquote><h2 id="结束">结束</h2><p>到这里OpenWrt简易校园网自动认证+双WAN配置基本上算是结束了，本人经验有限，也是在慢慢摸索中摸索出来的，如有错误欢迎指正，如愿意跟我交流或是有疑问可发邮件<a href="mailto:dingwh2023@126.com">dingwh2023@126.com</a>联系我。</p>]]></content>
    
    
    <categories>
      
      <category>OpenWrt</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenWrt</tag>
      
      <tag>网络配置</tag>
      
      <tag>自动认证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2024/07/03/2024-7-3-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2024/07/03/2024-7-3-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/2024/07/03/2024-7-3-%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/%E6%9E%B6%E6%9E%84%E5%9B%BE1.png" class="" title="图片引用方法一"><p><img src="%E6%9E%B6%E6%9E%84%E5%9B%BE1.png" alt="图片引用方法二"></p><p><img src="/images/%E6%9E%B6%E6%9E%84%E5%9B%BE1.png" alt="图片引用方法三"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
